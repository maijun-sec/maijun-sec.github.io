<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>流图的广度优先遍历</title>
    <url>/2022/10/30/graph-search-bfs/</url>
    <content><![CDATA[<h2 id="1-流图遍历引入"><a href="#1-流图遍历引入" class="headerlink" title="1. 流图遍历引入"></a>1. 流图遍历引入</h2><p>流图有两种遍历方式：深度优先遍历 和 广度优先遍历。</p>
<p>针对 流图的概念，和 流图的深度优先遍历，大家可以参考：<a href="https://maijun-sec.github.io/2022/10/27/graph-search-basic">流图的深度优先遍历</a>。</p>
<p>本文将简单介绍流图的广度优先遍历。</p>
<h2 id="2-流图的广度优先遍历"><a href="#2-流图的广度优先遍历" class="headerlink" title="2. 流图的广度优先遍历"></a>2. 流图的广度优先遍历</h2><p>广度优先遍历，是一种根据节点到 entry 的远近顺序遍历的一种方法，离 entry 最近的总是被最先遍历。</p>
<p>下面举个例子进行介绍：</p>
<p><img src="/2022/10/30/graph-search-bfs/bfs_flowgraph.png" alt="流图的深度优先遍历"></p>
<p>我们使用的例子，仍然是我们在介绍深度优先遍历的例子，看上图(左)。</p>
<p>针对广度优先遍历，我们以下面的表的格式进行介绍：</p>
<p>该表格每一行表示待遍历的节点序列，我们在遍历开始时，先将 entry 放到队列中，然后在后续遍历中，取出待遍历队列的 队首节点，然后再将本地处理中获得的待遍历的节点放入待遍历队列（在下面的表格中，我们将 <strong>取出节点</strong> 的动作表示为 <strong>节点置灰</strong>）。</p>
<p>例如 第2次，我们将 A 设置为灰色 表示从待遍历队列中取出该节点，然后将 B 和 C 放到待遍历队列中，此时 B 为 队首，即下一次遍历的节点。</p>
<p><img src="/2022/10/30/graph-search-bfs/img_1.png" alt="广度优先指向流程"></p>
<p>如果某一次迭代的时候，发现某个出边指向的节点已经有进行遍历，就不会再放，例如 第7次 迭代的 E 节点，因为 H 节点已经遍历过，就不会再重新放。</p>
<p>最后，就形成了上图(中)的遍历信息：</p>
<ul>
<li>绿色实线 表示在遍历中，真正存在遍历序的关系</li>
<li>红色虚线 表示不需要遍历的边</li>
</ul>
<p>由绿色实现组成的树，就是 <strong>广度优先生成树</strong>。</p>
<h2 id="3-广度优先遍历代码举例"><a href="#3-广度优先遍历代码举例" class="headerlink" title="3. 广度优先遍历代码举例"></a>3. 广度优先遍历代码举例</h2><p>简单实现一个广度优先遍历的算法（基于 jgrapht 实现，我们在实现静态代码分析框架时，CFG 就是用 jgrapht 保存的）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BFSIterator</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">// 待遍历的图</span></span><br><span class="line">    <span class="keyword">private</span> Graph&lt;V, DefaultEdge&gt; graph;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点是否已经被遍历到</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;V&gt; visited;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 待遍历的节点队列</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;V&gt; waitedVisitNodes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以图的形式创建 BFS树</span></span><br><span class="line">    <span class="keyword">private</span> Graph&lt;V, DefaultEdge&gt; bfsTree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// List形式存储，遍历顺序</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;V&gt; iteratorOrder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BFSIterator</span><span class="params">(Graph&lt;V, DefaultEdge&gt; graph, V entry)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.graph = graph;</span><br><span class="line">        iteratorOrder = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(graph.vertexSet().size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 BFS树，并将所有的节点放进去</span></span><br><span class="line">        bfsTree = <span class="keyword">new</span> <span class="title class_">DefaultDirectedGraph</span>&lt;&gt;(DefaultEdge.class);</span><br><span class="line">        graph.vertexSet().forEach(vertex -&gt; bfsTree.addVertex(vertex));</span><br><span class="line"></span><br><span class="line">        iteratorOrder = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(graph.vertexSet().size());</span><br><span class="line"></span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待遍历节点列表，并将 entry 节点放入到待遍历队列</span></span><br><span class="line">        waitedVisitNodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        waitedVisitNodes.add(entry);</span><br><span class="line"></span><br><span class="line">        bfs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 广度优先遍历图</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (waitedVisitNodes.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">cur</span> <span class="operator">=</span> waitedVisitNodes.remove(<span class="number">0</span>);</span><br><span class="line">            iteratorOrder.add(cur);</span><br><span class="line">            visited.add(cur);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (DefaultEdge edge : graph.outgoingEdgesOf(cur)) &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">node</span> <span class="operator">=</span> graph.getEdgeTarget(edge);</span><br><span class="line">                <span class="keyword">if</span> (waitedVisitNodes.contains(node) || visited.contains(node)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                waitedVisitNodes.add(node);</span><br><span class="line">                bfsTree.addEdge(cur, node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Graph&lt;V, DefaultEdge&gt; <span class="title function_">getBfsTree</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.bfsTree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;V, Integer&gt; <span class="title function_">getBfn</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;V, Integer&gt; bfn = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; iteratorOrder.size(); i++) &#123;</span><br><span class="line">            bfn.put(iteratorOrder.get(i), i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bfn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们测试这个广度优先实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BFSIteratorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 初始化流图</span></span><br><span class="line">        Graph&lt;String, DefaultEdge&gt; graph = initGraph();</span><br><span class="line"></span><br><span class="line">        BFSIterator&lt;String&gt; bfsIterator = <span class="keyword">new</span> <span class="title class_">BFSIterator</span>&lt;&gt;(graph, <span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">var</span> <span class="variable">bfsTree</span> <span class="operator">=</span> bfsIterator.getBfsTree();</span><br><span class="line">        System.out.println(bfsTree);</span><br><span class="line"></span><br><span class="line">        <span class="type">var</span> <span class="variable">dfn</span> <span class="operator">=</span> bfsIterator.getBfn();</span><br><span class="line">        dfn.entrySet().forEach(entry -&gt; System.out.println(entry.getKey() + <span class="string">&quot; -&gt; &quot;</span> + entry.getValue()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DefaultDirectedGraph&lt;String, DefaultEdge&gt; <span class="title function_">initGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        DefaultDirectedGraph&lt;String, DefaultEdge&gt; graph = <span class="keyword">new</span> <span class="title class_">DefaultDirectedGraph</span>&lt;&gt;(DefaultEdge.class);</span><br><span class="line"></span><br><span class="line">        graph.addVertex(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;E&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;F&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;G&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;I&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;J&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;K&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;L&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line">        graph.addEdge(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;G&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;E&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;H&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;D&quot;</span>, <span class="string">&quot;F&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;D&quot;</span>, <span class="string">&quot;G&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;E&quot;</span>, <span class="string">&quot;H&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;E&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;F&quot;</span>, <span class="string">&quot;I&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;F&quot;</span>, <span class="string">&quot;K&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;G&quot;</span>, <span class="string">&quot;J&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;H&quot;</span>, <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;L&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;J&quot;</span>, <span class="string">&quot;I&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;K&quot;</span>, <span class="string">&quot;L&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;L&quot;</span>, <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;L&quot;</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出来的 BFS树 和 BFN序列：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">([A, B, C, D, E, F, G, H, I, J, K, L, M], [(A,B), (A,C), (B,D), (B,G), (C,E), (C,H), (D,F), (G,J), (H,M), (F,I), (F,K), (I,L)])</span><br><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">D -&gt; 4</span><br><span class="line">E -&gt; 6</span><br><span class="line">F -&gt; 8</span><br><span class="line">G -&gt; 5</span><br><span class="line">H -&gt; 7</span><br><span class="line">I -&gt; 11</span><br><span class="line">J -&gt; 9</span><br><span class="line">K -&gt; 12</span><br><span class="line">L -&gt; 13</span><br><span class="line">M -&gt; 10</span><br></pre></td></tr></table></figure>

<p>跟前面的分析是一致的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《算法导论》22.2 节<br>《现代编译原理》19.2 节</p>
]]></content>
      <categories>
        <category>图论</category>
        <category>流图遍历</category>
      </categories>
      <tags>
        <tag>流图</tag>
        <tag>广度优先遍历</tag>
        <tag>广度优先搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>流图的深度优先遍历</title>
    <url>/2022/10/27/graph-search-basic/</url>
    <content><![CDATA[<h2 id="1-流图"><a href="#1-流图" class="headerlink" title="1. 流图"></a>1. 流图</h2><p>本文介绍的图虽然部分适用于通用的图论知识，但是因为主要是为静态分析的基础算法服务的，因此还是对分析的图结构进行限制。</p>
<p>本文介绍的流图具有如下的特点：</p>
<ul>
<li>有唯一的 entry 节点</li>
<li>是一个有向图，并且图中可能有环</li>
<li>从 entry 出发，顺着边可以直接或者间接到达程序中的所有的节点</li>
</ul>
<span id="more"></span>

<p>从根节点出发遍历图中的每个节点，并且每个节点仅被访问一次，称为<strong>图的遍历</strong>。 类似与树的遍历，图也有深度优先和广度优先两种遍历方式，不同的是，图中会有环，因此需要对已经访问的节点进行记录，避免重复遍历。</p>
<p>针对流图的遍历，有两种方式：深度优先遍历和广度优先遍历。</p>
<h2 id="2-流图深度优先遍历"><a href="#2-流图深度优先遍历" class="headerlink" title="2. 流图深度优先遍历"></a>2. 流图深度优先遍历</h2><h3 id="2-1-深度优先遍历举例介绍"><a href="#2-1-深度优先遍历举例介绍" class="headerlink" title="2.1 深度优先遍历举例介绍"></a>2.1 深度优先遍历举例介绍</h3><p>深度优先遍历所使用的策略，就跟它的名字一样：只要有可能，就会沿着图尽可能地进行“深入”遍历。具体来说，就是遍历到某个节点时，会先沿着这个节点的出边进行尽可能深入地遍历，等遍历结束后，会回溯到上个节点再继续遍历，直到遍历完成。</p>
<p>下面会举个例子进行介绍，</p>
<p><img src="/2022/10/27/graph-search-basic/dfs_flowgraph.png"></p>
<p>如上图(左)，是一个流图，其 entry 为 A 节点（所有的遍历的入口）。</p>
<p>其深度优先遍历的顺序如 上图(中) 所示：</p>
<p>我们对遍历顺序进行详细介绍。</p>
<p><strong>说明</strong>：</p>
<ul>
<li>有向图每个节点的出边，一般没有顺序，即不管先遍历哪一个都行</li>
<li>我们为了方便，每次都是沿着左边进行遍历</li>
</ul>
<p>如上图所示，遍历的步骤如下：</p>
<ul>
<li>entry 为 A，即 A 为第一个被遍历到，其序号为 1</li>
<li>A 有两条出边，沿左边的出边遍历，即 B，其序号为 2</li>
<li>B 有两条出边，沿左边的出边遍历，即 D，其序号为 3</li>
<li>D 有两条出边，沿左边的出边遍历，即 F，其序号为 4</li>
<li>F 有两条出边，沿左边的出边遍历，即 I，其序号为 5</li>
<li>I 只有一条出边，沿该出边遍历，即 L，其序号为 6</li>
<li>L 有两条出边，但是因为左边的出边为 B，已经遍历到，改沿右边的出边遍历，即 M，其序号为 7</li>
<li>M 没有出边，此时我们进行回溯，M 回溯到 L，我们发现 L 的两条边都已经遍历到，继续回溯</li>
<li>回溯到 L，L 只有一条出边，也已经遍历到，继续回溯到 F</li>
<li>F 有两条出边，其中左边 L 已经被遍历，此时沿右边遍历，即 K，其序号为 8</li>
<li>K 有一条出边，为 L，但是已经遍历，不再遍历，开始回溯</li>
<li>回溯到 F，发现 F 的两条出边都已经遍历到，此时继续回溯到 D</li>
<li>D 有两条出边，其中左边的出边已经遍历到，此时遍历右边的出边，即 G，其序号为 9</li>
<li>G 只有一条出边，沿该出边遍历，即 J，其序号为 10</li>
<li>J 有一条出边，但是出边 L 已经被遍历到，不再遍历，开始回溯</li>
<li>此时，通过反向回溯到 G，再到 D，再到 B，都没有未遍历的边，继续回溯到 A</li>
<li>A 左边的出边已经遍历，改为遍历右边的出边，即 C，其序号为 11</li>
<li>C 有两个出边，沿左边的出边遍历，即 E，其序号为 12</li>
<li>E 有两条出边，但是左边的出边到 C，已经遍历，改为右边的出边，即 H，其序号为 13</li>
<li>H 有一条出边，但是指向 M，已经遍历到，不再遍历，开始回溯</li>
<li>H 回溯到 E，E 两条边都已经遍历到，继续回溯到 C，看右边的出边，但是右边的出边也遍历到，不再遍历。</li>
<li>此时遍历结束。</li>
</ul>
<p>就形成了上图(中)，我们标出来的每个节点的遍历的次序。如上图，我们给每个节点都标注了数字，即遍历的顺序。</p>
<h3 id="2-2-和深度优先遍历相关的几个概念"><a href="#2-2-和深度优先遍历相关的几个概念" class="headerlink" title="2.2 和深度优先遍历相关的几个概念"></a>2.2 和深度优先遍历相关的几个概念</h3><h4 id="2-2-1-dfn序"><a href="#2-2-1-dfn序" class="headerlink" title="2.2.1 dfn序"></a>2.2.1 dfn序</h4><p>如上一节，在通过深度优先遍历遍历图时，对每个节点的遍历顺序按数字排序，例如 A 为 1，H 为 13，这个数字就是该节点的 dfn 序：</p>
<ul>
<li>dfn(A) &#x3D; 1</li>
<li>dfn(H) &#x3D; 13</li>
</ul>
<p><strong>说明</strong>：</p>
<ul>
<li>在有些资料里面，dfn 序从 0 开始，其实没什么影响，只是起始序号不同</li>
<li>在有些资料里面，dfn 也命名为 dfnum，大家知道两者一样即可，例如 dfnum(H)&#x3D;13</li>
</ul>
<h4 id="2-2-2-深度优先生成树-dfs树"><a href="#2-2-2-深度优先生成树-dfs树" class="headerlink" title="2.2.2 深度优先生成树(dfs树)"></a>2.2.2 深度优先生成树(dfs树)</h4><p>如上一节中，我们在介绍遍历顺序的时候，沿着有效遍历节点，我们通过<strong>绿色粗实线</strong>标注了遍历的关系，我们将图中的红色虚线去除，就形成了一个树状结构，如2.1节中的图(右)</p>
<p>这是一个树状结构，我们将其称为 <strong>DFS树</strong> 或者是 <strong>深度优先生成树</strong>。</p>
<p>针对 深度优先生成树，有几点需要说明的情况：</p>
<ul>
<li>深度优先生成树不是唯一的，如上例，我们遍历的时候，都是延左边的出边执行的，如果延右边的出边，或者部分延左边的出边，部分延右边的出边，形成的深度优先生成树可能不同；</li>
<li>深度优先生成树是一棵树，不是图，没有环，因此适用于树的概念：比如祖先、真祖先（如果一个节点v在节点w和根节点之间(包括w和根节点)，则v是w的祖先，如果v和w不同，则v是w的真祖先）；</li>
<li>如果 v 是 w 的真祖先，则 dfn(v) &lt; dfn(w)</li>
</ul>
<h4 id="2-2-3-几种边的类型"><a href="#2-2-3-几种边的类型" class="headerlink" title="2.2.3 几种边的类型"></a>2.2.3 几种边的类型</h4><p>在2.1节中，我们对深度优先遍历举例时，我们主要形成了三类数据：</p>
<ul>
<li>和节点在一起的数字，即 dfn 序</li>
<li>绿色实线边组成的树，即 深度优先生成树</li>
<li>红色虚线边</li>
</ul>
<p>这一节，我们介绍一下红色虚线边，我们将红色虚线边分成三类，大家继续看2.1节中形成的图：</p>
<ul>
<li>前向边：将节点 v 连接到 dfs树 中 v 的后代节点 w 的边，如 B-&gt;G，C-&gt;H</li>
<li>后向边：和前向边相反，是节点 v 连接到 dfs 树中 v 的祖先节点 w 的边，如 L-&gt;B，E-&gt;C</li>
<li>横向边：其它的在 DFS树 中不存在祖先和后代关系，但是在CFG中有边连接的点的边，如 J-&gt;L，H-&gt;M</li>
</ul>
<h2 id="3-深度优先遍历代码举例"><a href="#3-深度优先遍历代码举例" class="headerlink" title="3. 深度优先遍历代码举例"></a>3. 深度优先遍历代码举例</h2><p>我们简单实现一个基于深度优先遍历流图的算法（基于 jgrapht 实现）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DFSIterator</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Graph&lt;V, DefaultEdge&gt; graph;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以图的形式创建 DFS树，并添加所有的节点，等后面遍历时，再添加边</span></span><br><span class="line">    <span class="keyword">private</span> Graph&lt;V, DefaultEdge&gt; dfsTree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dfn序，List形式存储</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;V&gt; iteratorOrder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录已经访问的节点列表</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;V&gt; visited;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DFSIterator</span><span class="params">(Graph&lt;V, DefaultEdge&gt; graph, V entry)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.graph = graph;</span><br><span class="line"></span><br><span class="line">        iteratorOrder = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(graph.vertexSet().size());</span><br><span class="line"></span><br><span class="line">        dfsTree = <span class="keyword">new</span> <span class="title class_">DefaultDirectedGraph</span>&lt;&gt;(DefaultEdge.class);</span><br><span class="line">        graph.vertexSet().forEach(vertex -&gt; dfsTree.addVertex(vertex));</span><br><span class="line"></span><br><span class="line">        iteratorOrder = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(graph.vertexSet().size());</span><br><span class="line"></span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        dfs(entry, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 深度优先遍历图</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> curNode 当前正要遍历的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preNode 上一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(V curNode, V preNode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited.contains(curNode)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// 如果已经完成遍历，则直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited.add(curNode);  <span class="comment">// 将当前节点放入到已访问节点</span></span><br><span class="line">        iteratorOrder.add(curNode);  <span class="comment">// 将当前节点直接塞到遍历节点序列中，这个序列就表示了节点的遍历顺序</span></span><br><span class="line">        <span class="keyword">if</span> (preNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            dfsTree.addEdge(preNode, curNode);  <span class="comment">// 在 DFS树 中添加边</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于深度优先遍历当前节点的子节点</span></span><br><span class="line">        graph.outgoingEdgesOf(curNode).forEach(edge -&gt; &#123;</span><br><span class="line">            dfs(graph.getEdgeTarget(edge), curNode);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Graph&lt;V, DefaultEdge&gt; <span class="title function_">getDfsTree</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.dfsTree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;V, Integer&gt; <span class="title function_">getDfn</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;V, Integer&gt; dfn = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; iteratorOrder.size(); i++) &#123;</span><br><span class="line">            dfn.put(iteratorOrder.get(i), i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过下面的方式，初始化一个 jgrapht 图（和前面的例子一致），然后使用我们前面创建的深度优先遍历类进行遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DFSIteratorTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 初始化流图</span></span><br><span class="line">        Graph&lt;String, DefaultEdge&gt; graph = initGraph();</span><br><span class="line"></span><br><span class="line">        DFSIterator&lt;String&gt; dfsIterator = <span class="keyword">new</span> <span class="title class_">DFSIterator</span>&lt;&gt;(graph, <span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">var</span> <span class="variable">dfsTree</span> <span class="operator">=</span> dfsIterator.getDfsTree();</span><br><span class="line">        System.out.println(<span class="string">&quot;====&gt; DFS Tree:&quot;</span>);</span><br><span class="line">        System.out.println(dfsTree);</span><br><span class="line">        </span><br><span class="line">        <span class="type">var</span> <span class="variable">dfn</span> <span class="operator">=</span> dfsIterator.getDfn();</span><br><span class="line">        System.out.println(<span class="string">&quot;====&gt; DFN:&quot;</span>);</span><br><span class="line">        dfn.entrySet().forEach(entry -&gt; System.out.println(entry.getKey() + <span class="string">&quot; -&gt; &quot;</span> + entry.getValue()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DefaultDirectedGraph&lt;String, DefaultEdge&gt; <span class="title function_">initGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        DefaultDirectedGraph&lt;String, DefaultEdge&gt; graph = <span class="keyword">new</span> <span class="title class_">DefaultDirectedGraph</span>&lt;&gt;(DefaultEdge.class);</span><br><span class="line"></span><br><span class="line">        graph.addVertex(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;E&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;F&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;G&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;I&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;J&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;K&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;L&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line">        graph.addEdge(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;G&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;E&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;H&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;D&quot;</span>, <span class="string">&quot;F&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;D&quot;</span>, <span class="string">&quot;G&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;E&quot;</span>, <span class="string">&quot;H&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;E&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;F&quot;</span>, <span class="string">&quot;I&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;F&quot;</span>, <span class="string">&quot;K&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;G&quot;</span>, <span class="string">&quot;J&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;H&quot;</span>, <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;L&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;J&quot;</span>, <span class="string">&quot;I&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;K&quot;</span>, <span class="string">&quot;L&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;L&quot;</span>, <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="string">&quot;L&quot;</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码，打印出来的 DFS树 和 dfn序 如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">====&gt; DFS Tree:</span><br><span class="line">([A, B, C, D, E, F, G, H, I, J, K, L, M], [(A,B), (B,D), (D,F), (F,I), (I,L), (L,M), (F,K), (D,G), (G,J), (A,C), (C,E), (E,H)])</span><br><span class="line">====&gt; DFN:</span><br><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 11</span><br><span class="line">D -&gt; 3</span><br><span class="line">E -&gt; 12</span><br><span class="line">F -&gt; 4</span><br><span class="line">G -&gt; 9</span><br><span class="line">H -&gt; 13</span><br><span class="line">I -&gt; 5</span><br><span class="line">J -&gt; 10</span><br><span class="line">K -&gt; 8</span><br><span class="line">L -&gt; 6</span><br><span class="line">M -&gt; 7</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：在 jgrapht 中，原本就有实现一个针对通用图的深度优先遍历的算法，大家可以参考：<a href="https://jgrapht.org/javadoc/org.jgrapht.core/org/jgrapht/traverse/DepthFirstIterator.html">DepthFirstIterator</a>。该实现算法跟《算法导论》中的介绍一致（遍历的时候，根据节点遍历情况，分 白色、灰色、黑色），这里不再介绍了。</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>《算法导论》22.3 节<br>《现代编译原理》19.2 节</p>
]]></content>
      <categories>
        <category>图论</category>
        <category>流图遍历</category>
      </categories>
      <tags>
        <tag>流图</tag>
        <tag>深度优先遍历</tag>
        <tag>深度优先搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】Antlr4简明使用教程</title>
    <url>/2022/10/26/program-representation-antlr-basic/</url>
    <content><![CDATA[<p><strong>说明</strong>：本文是作者首发在 华为云bbs 上的原创文章，原文链接是：<a href="https://bbs.huaweicloud.com/blogs/226877">https://bbs.huaweicloud.com/blogs/226877</a></p>
<h2 id="1-Antlr4简单介绍"><a href="#1-Antlr4简单介绍" class="headerlink" title="1. Antlr4简单介绍"></a>1. Antlr4简单介绍</h2><p>Antlr4（Another Tool for Language Recognition）是一款基于Java开发的开源的语法分析器生成工具，能够根据语法规则文件生成对应的语法分析器，广泛应用于DSL构建，语言词法语法解析等领域。现在在非常多的流行的框架中都用使用，例如，在构建特定语言的AST方面，CheckStyle工具，就是基于Antlr来解析Java的语法结构的（当前Java Parser是基于JavaCC来解析Java文件的，据说有规划在下个版本改用Antlr来解析），还有就是广泛应用在DSL构建上，著名的Eclipse Xtext就有使用Antlr。</p>
<span id="more"></span>

<p>Antlr可以生成不同target的AST（可参考：<a href="https://www.antlr.org/download.html">Antlr4下载地址</a>），包括Java、C++、JS、Python、C#等，可以满足不同语言的开发需求。当前Antlr最新稳定版本为4.9，Antlr4官方github仓库中，已经有数十种语言的grammer（<a href="https://github.com/antlr/grammars-v4">https://github.com/antlr/grammars-v4</a> ），不过虽然这么多语言的规则文法定义都在一个仓库中，但是每种语言的grammer的license是不一样的，如果要使用，需要参考每种语言自己的语法结构的license。</p>
<p>本文将首先介绍Antlr4 grammer的定义方式（简单介绍语法结构，并介绍如何基于IDEA Antlr4插件进行调试），然后介绍如何通过Antlr4 grammer生成对应的AST，最后介绍Antlr4 的两种AST遍历方式：Visitor方式和Listener方式。</p>
<h2 id="2-Antlr4规则文法"><a href="#2-Antlr4规则文法" class="headerlink" title="2. Antlr4规则文法"></a>2. Antlr4规则文法</h2><p>下面简单介绍一部分Antlr4的g4（grammar）文件的写法（主要参考Antlr4官方wiki：<a href="https://github.com/antlr/antlr4/blob/master/doc/index.md">https://github.com/antlr/antlr4/blob/master/doc/index.md</a> ）。最有效的学习Antlr4的规则文法的写法的方法，就是参考已有的规则文法，大家在学习中，可以参考已有语言的文法。而且Antlr4已经实现了数十种语言的文法，如果需要自己定义，可以参考和自己的语言最接近的文法来开发。</p>
<h3 id="2-1-Antlr4规则基本语法和关键字"><a href="#2-1-Antlr4规则基本语法和关键字" class="headerlink" title="2.1 Antlr4规则基本语法和关键字"></a>2.1 Antlr4规则基本语法和关键字</h3><p>首先，如果有一点儿C或者Java基础，对上手Antlr4 g4的文法非常快。主要有下面的一些文法结构：</p>
<ul>
<li>注释：和Java的注释完全一致，也可参考C的注释，只是增加了JavaDoc类型的注释；</li>
<li>标志符：参考Java或者C的标志符命名规范，针对Lexer 部分的 Token 名的定义，采用全大写字母的形式，对于parser rule命名，推荐首字母小写的驼峰命名；</li>
<li>不区分字符和字符串，都是用单引号引起来的，同时，虽然Antlr g4支持 Unicode编码（即支持中文编码），但是建议大家尽量还有英文；</li>
<li>Action，行为，主要有@header 和@members，用来定义一些需要生成到目标代码中的行为，例如，可以通过@header设置生成的代码的package信息，@members可以定义额外的一些变量到Antlr4语法文件中；</li>
<li>Antlr4语法中，支持的关键字有：import, fragment, lexer, parser, grammar, returns, locals, throws, catch, finally, mode, options, tokens。</li>
</ul>
<h3 id="2-2-Antlr4语法介绍"><a href="#2-2-Antlr4语法介绍" class="headerlink" title="2.2 Antlr4语法介绍"></a>2.2 Antlr4语法介绍</h3><h4 id="2-2-1语法文件的整体结构及写法示例"><a href="#2-2-1语法文件的整体结构及写法示例" class="headerlink" title="2.2.1语法文件的整体结构及写法示例"></a>2.2.1语法文件的整体结构及写法示例</h4><p>Antlr4整体结构如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/** Optional javadoc style comment */</span><br><span class="line"></span><br><span class="line">grammar Name;</span><br><span class="line"></span><br><span class="line">options &#123;...&#125;</span><br><span class="line"></span><br><span class="line">import ... ;</span><br><span class="line">tokens &#123;...&#125;</span><br><span class="line"></span><br><span class="line">channels &#123;...&#125; // lexer only</span><br><span class="line"></span><br><span class="line">@actionName &#123;...&#125;</span><br><span class="line">rule1 // parser and lexer rules, possibly intermingled</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ruleN</span><br></pre></td></tr></table></figure>

<p>一般如果语法非常复杂，会基于Lexer和Parser写到两个不同的文件中（例如Java，可参考：<a href="https://github.com/antlr/grammars-v4/tree/master/java/java8">https://github.com/antlr/grammars-v4/tree/master/java/java8</a> ），如果语法比较简单，可以只写到一个文件中（例如Lua，可参考：<a href="https://github.com/antlr/grammars-v4/blob/master/lua/Lua.g4">https://github.com/antlr/grammars-v4/blob/master/lua/Lua.g4</a> ）。</p>
<p>下面我们结合Lua.g4中的一部分语法结构，介绍使用方法。写Antlr4的文法，需要依据源码的结构来决定。定义时，依据源码文件的写法，从上到下开始构造语法结构。例如，下面是Lua.g4的一部分：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">chunk</span><br><span class="line">    : block EOF</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">block</span><br><span class="line">    : stat* retstat?</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">stat</span><br><span class="line">    : &#x27;;&#x27;</span><br><span class="line">    | varlist &#x27;=&#x27; explist</span><br><span class="line">    | functioncall</span><br><span class="line">    | label</span><br><span class="line">    | &#x27;break&#x27;</span><br><span class="line">    | &#x27;goto&#x27; NAME</span><br><span class="line">    | &#x27;do&#x27; block &#x27;end&#x27;</span><br><span class="line">    | &#x27;while&#x27; exp &#x27;do&#x27; block &#x27;end&#x27;</span><br><span class="line">    | &#x27;repeat&#x27; block &#x27;until&#x27; exp</span><br><span class="line">    | &#x27;if&#x27; exp &#x27;then&#x27; block (&#x27;elseif&#x27; exp &#x27;then&#x27; block)* (&#x27;else&#x27; block)? &#x27;end&#x27;</span><br><span class="line">    | &#x27;for&#x27; NAME &#x27;=&#x27; exp &#x27;,&#x27; exp (&#x27;,&#x27; exp)? &#x27;do&#x27; block &#x27;end&#x27;</span><br><span class="line">    | &#x27;for&#x27; namelist &#x27;in&#x27; explist &#x27;do&#x27; block &#x27;end&#x27;</span><br><span class="line">    | &#x27;function&#x27; funcname funcbody</span><br><span class="line">    | &#x27;local&#x27; &#x27;function&#x27; NAME funcbody</span><br><span class="line">    | &#x27;local&#x27; attnamelist (&#x27;=&#x27; explist)?</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">attnamelist</span><br><span class="line">    : NAME attrib (&#x27;,&#x27; NAME attrib)*</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>如上语法中，整个文件被表示成一个chunk，chunk表示为一个block和一个文件结束符（EOF）；block又被表示为一系列的语句的集合，而每一种语句又有特定的语法结构，包含了特定的表达式、关键字、变量、常量等信息，然后递归表达式的文法组成，变量的写法等，最终全部都归结到Lexer（Token）上，递归树结束。</p>
<p>上面其实已经可以看到Antlr4规则的写法，下面介绍一部分比较重要的规则的写法。</p>
<h4 id="2-2-2-替代标签"><a href="#2-2-2-替代标签" class="headerlink" title="2.2.2 替代标签"></a>2.2.2 替代标签</h4><p>首先，如2.2.1节的代码所示，stat可以有非常多的类型，例如变量定义、函数定义、if、while等，这些都没有进行区分，这样解析出来语法树时，会很不清晰，需要结合很多的标记完成具体语句的识别，这种情况下，我们可以结合替代标签完成区分，如下代码：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">stat</span><br><span class="line">    : &#x27;;&#x27;</span><br><span class="line">    | varlist &#x27;=&#x27; explist  #varListStat</span><br><span class="line">    | functioncall  #functionCallStat</span><br><span class="line">    | label  #labelStat</span><br><span class="line">    | &#x27;break&#x27;  #breakStat</span><br><span class="line">    | &#x27;goto&#x27; NAME  #gotoStat</span><br><span class="line">    | &#x27;do&#x27; block &#x27;end&#x27;  #doStat</span><br><span class="line">    | &#x27;while&#x27; exp &#x27;do&#x27; block &#x27;end&#x27;  #whileStat</span><br><span class="line">    | &#x27;repeat&#x27; block &#x27;until&#x27; exp  #repeatStat</span><br><span class="line">    | &#x27;if&#x27; exp &#x27;then&#x27; block (&#x27;elseif&#x27; exp &#x27;then&#x27; block)* (&#x27;else&#x27; block)? &#x27;end&#x27;  #ifStat</span><br><span class="line">    | &#x27;for&#x27; NAME &#x27;=&#x27; exp &#x27;,&#x27; exp (&#x27;,&#x27; exp)? &#x27;do&#x27; block &#x27;end&#x27;  #forStat</span><br><span class="line">    | &#x27;for&#x27; namelist &#x27;in&#x27; explist &#x27;do&#x27; block &#x27;end&#x27;  #forInStat</span><br><span class="line">    | &#x27;function&#x27; funcname funcbody  #functionDefStat</span><br><span class="line">    | &#x27;local&#x27; &#x27;function&#x27; NAME funcbody  #localFunctionDefStat</span><br><span class="line">    | &#x27;local&#x27; attnamelist (&#x27;=&#x27; explist)?  #localVarListStat</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>通过在语句后面，添加 #替代标签，可以将语句转换为这些替代标签，从而加以区分。</p>
<h4 id="2-2-3-操作符优先级处理"><a href="#2-2-3-操作符优先级处理" class="headerlink" title="2.2.3 操作符优先级处理"></a>2.2.3 操作符优先级处理</h4><p>默认情况下，ANTLR从左到右结合运算符，然而某些像指数群这样的运算符则是从右到左。可以使用选项assoc手动指定运算符记号上的相关性。如下面的操作：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">expr : expr &#x27;^&#x27;&lt;assoc=right&gt; expr</span><br></pre></td></tr></table></figure>

<p>^ 表示指数运算，增加 assoc&#x3D;right，表示该运算符是右结合。</p>
<p>实际上，Antlr4 已经对一些常用的操作符的优先级进行了处理，例如加减乘除等，这些就不需要再特殊处理。</p>
<h4 id="2-2-4-隐藏通道"><a href="#2-2-4-隐藏通道" class="headerlink" title="2.2.4 隐藏通道"></a>2.2.4 隐藏通道</h4><p>很多信息，例如注释、空格等，是结果信息生成不需要处理的，但是我们又不适合直接丢弃，安全地忽略掉注释和空格的方法是把这些发送给语法分析器的记号放到一个“隐藏通道”中，语法分析器仅需要调协到单个通道即可。我们可以把任何我们想要的东西传递到其它通道中。在Lua.g4中，这类信息的处理如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">COMMENT</span><br><span class="line">    : &#x27;--[&#x27; NESTED_STR &#x27;]&#x27; -&gt; channel(HIDDEN)</span><br><span class="line">    ;</span><br><span class="line">LINE_COMMENT</span><br><span class="line">    : &#x27;--&#x27;</span><br><span class="line">    (                                               // --</span><br><span class="line">    | &#x27;[&#x27; &#x27;=&#x27;*                                      // --[==</span><br><span class="line">    | &#x27;[&#x27; &#x27;=&#x27;* ~(&#x27;=&#x27;|&#x27;[&#x27;|&#x27;\r&#x27;|&#x27;\n&#x27;) ~(&#x27;\r&#x27;|&#x27;\n&#x27;)*   // --[==AA</span><br><span class="line">    | ~(&#x27;[&#x27;|&#x27;\r&#x27;|&#x27;\n&#x27;) ~(&#x27;\r&#x27;|&#x27;\n&#x27;)*                // --AAA</span><br><span class="line">    ) (&#x27;\r\n&#x27;|&#x27;\r&#x27;|&#x27;\n&#x27;|EOF)</span><br><span class="line">    -&gt; channel(HIDDEN)</span><br><span class="line">    ;</span><br><span class="line">WS</span><br><span class="line">    : [ \t\u000C\r\n]+ -&gt; skip</span><br><span class="line">    ;</span><br><span class="line">SHEBANG</span><br><span class="line">    : &#x27;#&#x27; &#x27;!&#x27; ~(&#x27;\n&#x27;|&#x27;\r&#x27;)* -&gt; channel(HIDDEN)</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>放到 channel(HIDDEN) 中的 Token，不会被语法解析阶段处理，但是可以通过Token遍历获取到。</p>
<h4 id="2-2-5-常见词法结构"><a href="#2-2-5-常见词法结构" class="headerlink" title="2.2.5 常见词法结构"></a>2.2.5 常见词法结构</h4><p>Antlr4采用BNF范式，用’|’表示分支选项，’*’表示匹配前一个匹配项0次或者多次，’+’ 表示匹配前一个匹配项至少一次。下面介绍几种常见的词法举例（均来自Lua.g4文件）：</p>
<ul>
<li>注释信息</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">COMMENT</span><br><span class="line">    : &#x27;--[&#x27; NESTED_STR &#x27;]&#x27; -&gt; channel(HIDDEN)</span><br><span class="line">    ;</span><br><span class="line">LINE_COMMENT</span><br><span class="line">    : &#x27;--&#x27;</span><br><span class="line">    (                                               // --</span><br><span class="line">    | &#x27;[&#x27; &#x27;=&#x27;*                                      // --[==</span><br><span class="line">    | &#x27;[&#x27; &#x27;=&#x27;* ~(&#x27;=&#x27;|&#x27;[&#x27;|&#x27;\r&#x27;|&#x27;\n&#x27;) ~(&#x27;\r&#x27;|&#x27;\n&#x27;)*   // --[==AA</span><br><span class="line">    | ~(&#x27;[&#x27;|&#x27;\r&#x27;|&#x27;\n&#x27;) ~(&#x27;\r&#x27;|&#x27;\n&#x27;)*                // --AAA</span><br><span class="line">    ) (&#x27;\r\n&#x27;|&#x27;\r&#x27;|&#x27;\n&#x27;|EOF)</span><br><span class="line">    -&gt; channel(HIDDEN)</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<ul>
<li>数字</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">INT</span><br><span class="line">    : Digit+</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">Digit</span><br><span class="line">    : [0-9]</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<ul>
<li>ID（命名）</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">: [a-zA-Z_][a-zA-Z_0-9]*</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<h2 id="3-基于IDEA调试Antlr4语法规则（文法可视化）"><a href="#3-基于IDEA调试Antlr4语法规则（文法可视化）" class="headerlink" title="3. 基于IDEA调试Antlr4语法规则（文法可视化）"></a>3. 基于IDEA调试Antlr4语法规则（文法可视化）</h2><p>如果要安装Antlr4，选择 File -&gt; Settings -&gt; Plugins，然后在搜索框搜索 Antlr安装即可，可以选择安装搜索出来的最新版本，下图是刚刚安装的ANTLR v4，版本是v1.15，支持最新的Antlr 4.9版本。IDEA安装Antlr.png<br><img src="/2022/10/26/program-representation-antlr-basic/idea_antlr_plugin.png"><br>基于IDEA调试Antlr4语法一般步骤：</p>
<p><strong>(1) 创建一个调试工程，并创建一个g4文件</strong></p>
<p>这里，我自己测试用Java开发，所以创建的是一个Maven工程，g4文件放在了src&#x2F;main&#x2F;resources 目录下，取名 Test.g4</p>
<p><strong>（2）写一个简单的语法结构</strong></p>
<p>这里我们参考写一个加减乘除操作的表达式，然后在赋值操作对应的Rule上右键，可选择测试：</p>
<p><img src="/2022/10/26/program-representation-antlr-basic/antlr_rule_test.png"></p>
<p>如上图，expr 表示的是一个乘法操作，所以我们如下测试：</p>
<p><img src="/2022/10/26/program-representation-antlr-basic/test_mult.png"></p>
<p>但是，如果改成一个加法操作，则无法识别，只能识别到第一个数字。</p>
<p><img src="/2022/10/26/program-representation-antlr-basic/test_add.png"></p>
<p>这种情况下，就需要继续扩充 expr的定义，丰富不同的语法，来继续支持其他的语法，如下：</p>
<p><img src="/2022/10/26/program-representation-antlr-basic/test_add_succ.png"></p>
<p>还可以继续扩充其他类型的支持，这样一步步将整个语言的语法都支持完整。这里，我们形成的一个完整的格式如下（表示整形数字的加减乘除）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">grammar Test;</span><br><span class="line"></span><br><span class="line">@header &#123;</span><br><span class="line">    package zmj.test.antlr4.parser;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stmt : expr;</span><br><span class="line"></span><br><span class="line">expr : expr NUL expr    # Mul</span><br><span class="line">    | expr ADD expr    # Add</span><br><span class="line">    | expr DIV expr    # Div</span><br><span class="line">    | expr MIN expr    # Min</span><br><span class="line">    | INT              # Int</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">NUL : &#x27;*&#x27;;</span><br><span class="line">ADD : &#x27;+&#x27;;</span><br><span class="line">DIV : &#x27;/&#x27;;</span><br><span class="line">MIN : &#x27;-&#x27;;</span><br><span class="line"></span><br><span class="line">INT : Digit+;</span><br><span class="line">Digit : [0-9];</span><br><span class="line"></span><br><span class="line">WS : [ \t\u000C\r\n]+ -&gt; skip;</span><br><span class="line"></span><br><span class="line">SHEBANG : &#x27;#&#x27; &#x27;!&#x27; ~(&#x27;\n&#x27;|&#x27;\r&#x27;)* -&gt; channel(HIDDEN);</span><br></pre></td></tr></table></figure>

<h2 id="4-Antlr4生成并遍历AST"><a href="#4-Antlr4生成并遍历AST" class="headerlink" title="4. Antlr4生成并遍历AST"></a>4. Antlr4生成并遍历AST</h2><h3 id="4-1-生成源码文件"><a href="#4-1-生成源码文件" class="headerlink" title="4.1 生成源码文件"></a>4.1 生成源码文件</h3><p>这一步介绍两种生成解析语法树的两种方法，供参考：</p>
<ul>
<li>Maven Antlr4插件自动生成（针对Java工程，也可以用于Gradle）</li>
</ul>
<p>pom.xml设置Antlr4 Maven插件，可以通过执行 <code>mvn generate-sources</code>自动生成需要的代码（参考链接： <a href="https://www.antlr.org/api/maven-plugin/latest/antlr4-mojo.html">https://www.antlr.org/api/maven-plugin/latest/antlr4-mojo.html</a> )，主要的意义在于，代码入库的时候，不需要再将生成的这些语法文件入库，减少库里面的代码冗余，只包含自己开发的代码，不会有自动生成的代码，也不需要做clean code整改，下面是一个示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.antlr<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>antlr4-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>antlr<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">goal</span>&gt;</span>antlr4<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-sources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>$&#123;basedir&#125;/src/main/resources<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/generated-sources/antlr4/zmj/test/antlr4/parser<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">listener</span>&gt;</span>true<span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">visitor</span>&gt;</span>true<span class="tag">&lt;/<span class="name">visitor</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">treatWarningsAsErrors</span>&gt;</span>true<span class="tag">&lt;/<span class="name">treatWarningsAsErrors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>按照上面设置后，只需要执行 <code>mvn generate-sources</code> 即可在maven工程中自动生成代码。</p>
<ul>
<li>命令行方式</li>
</ul>
<p>主要参考链接（<a href="https://www.antlr.org/download.html">https://www.antlr.org/download.html</a> ），有每种语言的语法配置，我们这里考虑下载Antlr4完整jar：</p>
<p><img src="/2022/10/26/program-representation-antlr-basic/antlr_download.png"></p>
<p>下载好后（antlr-4.9-complete.jar）,可以使用如下命令来生成需要的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ java -jar antlr-4.9-complete.jar -Dlanguage=Python3 -visitor Test.g4</span><br></pre></td></tr></table></figure>

<p>这样就可以生成Python3 target的源码，支持的源码可以从上面链接查看，如果不希望生成Listener，可以添加参数 -no-listener</p>
<h3 id="4-2-访问者模式遍历Antlr4语法树"><a href="#4-2-访问者模式遍历Antlr4语法树" class="headerlink" title="4.2 访问者模式遍历Antlr4语法树"></a>4.2 访问者模式遍历Antlr4语法树</h3><p>Antlr4在AST遍历时，支持两种设计模式：访问者设计模式 和 监听器模式。</p>
<p>对于 访问者设计模式，我们需要自己定义对 AST 的访问（<a href="https://maijun-sec.github.io/2022/10/26/program-representation-visitor/">https://maijun-sec.github.io/2022/10/26/program-representation-visitor/</a> ） ，这是一篇针对访问者设计模式的介绍，大家可以参考。下面直接通过代码展示访问者模式在Antlr4中使用（基于第3章的例子）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.CharStream;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.CharStreams;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.CommonTokenStream;</span><br><span class="line"><span class="keyword">import</span> zmj.test.antlr4.parser.TestBaseVisitor;</span><br><span class="line"><span class="keyword">import</span> zmj.test.antlr4.parser.TestLexer;</span><br><span class="line"><span class="keyword">import</span> zmj.test.antlr4.parser.TestParser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CharStream</span> <span class="variable">input</span> <span class="operator">=</span> CharStreams.fromString(<span class="string">&quot;12*2+12&quot;</span>);</span><br><span class="line">        TestLexer lexer=<span class="keyword">new</span> <span class="title class_">TestLexer</span>(input);</span><br><span class="line">        <span class="type">CommonTokenStream</span> <span class="variable">tokens</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonTokenStream</span>(lexer);</span><br><span class="line">        <span class="type">TestParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestParser</span>(tokens);</span><br><span class="line">        TestParser.<span class="type">ExprContext</span> <span class="variable">tree</span> <span class="operator">=</span> parser.expr();</span><br><span class="line">        <span class="type">TestVisitor</span> <span class="variable">tv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestVisitor</span>();</span><br><span class="line">        tv.visit(tree);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TestVisitor</span> <span class="keyword">extends</span> <span class="title class_">TestBaseVisitor</span>&lt;Void&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Void <span class="title function_">visitAdd</span><span class="params">(TestParser.AddContext ctx)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;========= test add&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;first arg: &quot;</span> + ctx.expr(<span class="number">0</span>).getText());</span><br><span class="line">            System.out.println(<span class="string">&quot;second arg: &quot;</span> + ctx.expr(<span class="number">1</span>).getText());</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.visitAdd(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，main方法中，解析出了表达式的AST结构，同时在源码中也定义了一个Visitor：TestVisitor，访问AddContext，并且打印该加表达式的前后两个表达式，上面例子的输出为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">========= test add</span><br><span class="line">first arg: 12*2</span><br><span class="line">second arg: 12</span><br></pre></td></tr></table></figure>

<h3 id="4-2-监听器模式（观察者模式）"><a href="#4-2-监听器模式（观察者模式）" class="headerlink" title="4.2 监听器模式（观察者模式）"></a>4.2 监听器模式（观察者模式）</h3><p>对于监听器模式，就是通过监听某对象，如果该对象上有特定的事件发生，则触发该监听行为执行。比如有个监控（监听器），监控的是大门（事件对象），如果发生了闯门的行为（事件源），则进行报警（触发操作行为）。</p>
<p>在Antlr4中，如果使用监听器模式，首先需要开发一个监听器，该监听器可以监听每个AST节点（例如表达式、语句等）的不同的行为（例如进入该节点、结束该节点）。在使用时，Antlr4会对生成的AST进行遍历（ParseTreeWalker），如果遍历到某个具体的节点，并且执行了特定行为，就会触发监听器的事件。</p>
<p>监听器方法是没有返回值的（即返回类型是void）。因此需要一种额外的数据结构（可以通过Map或者栈）来存储当次的计算结果，供下一次计算调用。</p>
<p>一般来说，面向程序静态分析时，都是使用访问者模式的，很少使用监听器模式（无法主动控制遍历AST的顺序，不方便在不同节点遍历之间传递数据），用法对咱们也不友好，所以本文不介绍监听器模式，如果有兴趣，可以自己搜索测试使用。</p>
<h2 id="5-Antlr4词法解析和语法解析"><a href="#5-Antlr4词法解析和语法解析" class="headerlink" title="5. Antlr4词法解析和语法解析"></a>5. Antlr4词法解析和语法解析</h2><p>这部分实际上，算是Antlr4最基础的内容，但是放到最后一部分来讲，有特定的目的，就是探讨一下词法解析和语法解析的界限，以及Antlr4的结果的处理。</p>
<h3 id="5-1-Antlr4执行阶段"><a href="#5-1-Antlr4执行阶段" class="headerlink" title="5.1 Antlr4执行阶段"></a>5.1 Antlr4执行阶段</h3><p>如前面的语法定义，分为Lexer和Parser，实际上表示了两个不同的阶段：</p>
<p>词法分析阶段：对应于Lexer定义的词法规则，解析结果为一个一个的Token；<br>解析阶段：根据词法，构造出来一棵解析树或者语法树。<br>如下图所示：</p>
<p><img src="/2022/10/26/program-representation-antlr-basic/antlr_step.png"></p>
<h3 id="5-2-词法解析和语法解析的调和"><a href="#5-2-词法解析和语法解析的调和" class="headerlink" title="5.2 词法解析和语法解析的调和"></a>5.2 词法解析和语法解析的调和</h3><p>首先，我们应该有个普遍的认知：语法解析相对于词法解析，会产生更多的开销，所以，应该尽量将某些可能的处理在词法解析阶段完成，减少语法解析阶段的开销，主要下面的这些例子：</p>
<p>合并语言不关心的标记，例如，某些语言（例如js）不区分int、double，只有 number，那么在词法解析阶段，就不需要将int和double区分开，统一合并为一个number；<br>空格、注释等信息，对于语法解析并无大的帮助，可以在词法分析阶段剔除掉；<br>诸如标志符、关键字、字符串和数字这样的常用记号，均应该在词法解析时完成，而不要到语法解析阶段再进行。<br>但是，这样的操作在节省了语法分析的开销之外，其实对我们也产生了一些影响：</p>
<p>虽然语言不区分类型，例如只有 number，没有 int 和 double 等，但是面向静态代码分析，我们可能需要知道确切的类型来帮助分析特定的缺陷；<br>虽然注释对代码帮助不大，但是我们有时候也需要解析注释的内容来进行分析，如果无法在语法解析的时候获取，那么就需要遍历Token，从而导致静态代码分析开销更大等；<br>…<br>这样的一些问题该如何处理呢？</p>
<h3 id="5-3-解析树vs语法树"><a href="#5-3-解析树vs语法树" class="headerlink" title="5.3 解析树vs语法树"></a>5.3 解析树vs语法树</h3><p>大部分的资料中，都把Antlr4生成的树状结构，称为解析树或者是语法树，但是，如果我们细究的话，可能说成是解析树更加准确，因为Antlr4的结果，只是简单的文法解析，不能称之为语法树（语法树应该是能够体现出来语法特性的信息），如上面的那些问题，就很难在Antlr4生成的解析树上获取到。</p>
<p>所以，现在很多工具，基于Antlr4进行封装，然后进行了更进一步地处理，从而获取到了更加丰富的语法树，例如CheckStyle。因此，如果通过Antlr4解析语言简单使用，可以直接基于Antlr4的结果开发，但是如果要进行更加深入的处理，就需要对Antlr4的结果进行更进一步的处理，以更符合我们的使用习惯（例如，Java Parser格式的Java的AST，Clang格式的C&#x2F;C++的AST），然后才能更好地在上面进行开发。</p>
]]></content>
      <categories>
        <category>程序分析</category>
        <category>程序表示</category>
        <category>AST解析与操作</category>
      </categories>
      <tags>
        <tag>Antlr4</tag>
      </tags>
  </entry>
  <entry>
    <title>用于静态代码分析的程序表示——AST获取</title>
    <url>/2022/10/25/program-representation-ast-gen/</url>
    <content><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>我们这里，标题用 AST获取，而不是 AST生成，主要目的在于，我们在开发静态代码分析工具时，应该善于利用已有的开源工具或者框架，避免重复造轮子，期望采用最少的投入获得最大的回报。</p>
<p>当然，有时候已有的开源工具或者框架对于我们来说可能并不合适，这个时候还是要自己生成的。</p>
<span id="more"></span>

<h2 id="2-常用的代码-AST-获取或生成方法"><a href="#2-常用的代码-AST-获取或生成方法" class="headerlink" title="2. 常用的代码 AST 获取或生成方法"></a>2. 常用的代码 AST 获取或生成方法</h2><h3 id="2-1-选择已有的开源代码或者框架"><a href="#2-1-选择已有的开源代码或者框架" class="headerlink" title="2.1 选择已有的开源代码或者框架"></a>2.1 选择已有的开源代码或者框架</h3><p>这里，简单介绍一些面向主流语言，常有的一些框架如下：</p>
<table>
<thead>
<tr>
<th>语言</th>
<th>开源框架及静态分析工具或编译器</th>
</tr>
</thead>
<tbody><tr>
<td>Java</td>
<td>JDT、JavaParser、PMD、CheckStyle等</td>
</tr>
<tr>
<td>C&#x2F;C++</td>
<td>CDT、CppCheck、Clang等</td>
</tr>
<tr>
<td>Python</td>
<td>Python自带的 ast 模块、Bandit、flake8等</td>
</tr>
<tr>
<td>JavaScript</td>
<td>Babel、espree、eslint、prettier 等</td>
</tr>
</tbody></table>
<p><strong>说明</strong>：</p>
<ul>
<li>Java 的 findbugs 是扫描 class 文件的，没有列在上面；</li>
<li>针对 JavaParser，有一个介绍，可以参考：<a href="https://maijun-sec.github.io/2022/10/25/program-representation-javaparser-intro/">JavaParser简介及应用</a>，可以使大家对AST有个更直观的认识。</li>
</ul>
<p>当我们开发程序分析工具时，需要 AST 的情况下，首选当然是开源代码，可以快速实现开发，快速迭代。但是，如果需要支持多种语言，并且希望针对多种语言，统一 AST 格式，则还是需要自己生成 AST。</p>
<h3 id="2-2-基于-Antlr4-或者-Java-CC-生成-AST"><a href="#2-2-基于-Antlr4-或者-Java-CC-生成-AST" class="headerlink" title="2.2 基于 Antlr4 或者 Java CC 生成 AST"></a>2.2 基于 Antlr4 或者 Java CC 生成 AST</h3><p>Antlr4是一款基于Java开发的开源的语法分析器生成工具，广泛应用于DSL构建，语言词法语法解析，静态代码分析等领域。</p>
<p>针对 Antlr4 的介绍和使用，可以参考：<a href="https://maijun-sec.github.io/2022/10/26/program-representation-antlr-basic/">Antlr4简明使用教程</a></p>
<p>该方法应用范围非常广，例如 JavaParser 和 PMD（PMD 中部分非 Java 的语言基于 Antlr4 实现） 都是基于 Java CC 实现的。</p>
<h4 id="2-2-1-具体语法树和抽象语法树"><a href="#2-2-1-具体语法树和抽象语法树" class="headerlink" title="2.2.1 具体语法树和抽象语法树"></a>2.2.1 具体语法树和抽象语法树</h4><p><font color="red">待补充</font></p>
<h4 id="2-2-2-从具体语法树到抽象语法树"><a href="#2-2-2-从具体语法树到抽象语法树" class="headerlink" title="2.2.2 从具体语法树到抽象语法树"></a>2.2.2 从具体语法树到抽象语法树</h4><p><font color="red">待补充</font></p>
<h4 id="2-2-3-token获取"><a href="#2-2-3-token获取" class="headerlink" title="2.2.3 token获取"></a>2.2.3 token获取</h4><p><font color="red">待补充</font></p>
<h3 id="2-3-基于词法分析生成"><a href="#2-3-基于词法分析生成" class="headerlink" title="2.3 基于词法分析生成"></a>2.3 基于词法分析生成</h3><p>说实话，自己解析 token，然后通过自己实现 上下文无关文法 的解析，然后构造 AST，我还没有做过，这里就先不介绍了，大家可以参考部分编译器（例如 clang）的实现，或者看看 Antlr4 的源码。以后我要是做到了这部分工作，我再回来补充。</p>
<h2 id="3-AST-的遍历"><a href="#3-AST-的遍历" class="headerlink" title="3. AST 的遍历"></a>3. AST 的遍历</h2><p>针对 AST 的遍历，主要是两种设计模式：访问者设计模式 和 监听者设计模式</p>
<p>针对这两部分，可以参考下面的两个博客：</p>
<ul>
<li>Antlr4 的遍历：<a href="https://maijun-sec.github.io/2022/10/26/program-representation-antlr-basic/">Antlr4简明使用教程</a></li>
<li>一个访问者模式的介绍，并且结合具体例子介绍：<a href="https://maijun-sec.github.io/2022/10/26/program-representation-visitor/">访问者模式及其在 Java Parser 中的应用</a></li>
</ul>
]]></content>
      <categories>
        <category>程序分析</category>
        <category>程序表示</category>
        <category>AST解析与操作</category>
      </categories>
      <tags>
        <tag>AST</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】静态代码分析中间表示基本概念——AST、三地址码、CFG、SSA概念</title>
    <url>/2022/10/24/program-representation-ast-ssa/</url>
    <content><![CDATA[<p><strong>说明</strong>：本文是作者首发在华为云bbs上的原创文章，原文链接是：<a href="https://bbs.huaweicloud.com/blogs/227535">https://bbs.huaweicloud.com/blogs/227535</a></p>
<h2 id="0-简介"><a href="#0-简介" class="headerlink" title="0 简介"></a>0 简介</h2><p>静态代码分析是指在不实际执行程序的情况下，对代码语义和行为进行分析，由此找出程序中由于错误的编码导致异常的程序语义或未定义的行为。它能在软件开发流程早期就发现代码中的各种问题，从而提高开发效率和软件质量。</p>
<span id="more"></span>

<p>静态代码分析，从工具实现的角度，就是开发一款分析器，对程序源代码进行分析，识别程序中的各种类型的问题。为了识别这些问题，开发分析器就需要不同的实现方式（算法），这时候，为了让分析器在实现时更加简洁、高效，就需要对源代码进行处理，转换为一种针对特定的分析器算法和源码在语义上等价的，但是更加简洁、高效、实用的表示形式，也就是中间表示。</p>
<p>就像源码，里面包含各种注释等内容，很不方便分析，一般也不会基于源码来直接分析，都会转换为某种格式来分析。当然，我们介绍的都是当前静态代码分析（编译原理）里面最经典的一些中间表示。首先，会介绍一下AST，然后会介绍一下三地址码，随后介绍一下SSA形式的三地址码，最后介绍一下什么是CFG（包括BB块）和CG。</p>
<h2 id="1-AST和三地址码"><a href="#1-AST和三地址码" class="headerlink" title="1 AST和三地址码"></a>1 AST和三地址码</h2><p>在介绍AST和三地址码时，我们用一个简单的例子：<code>x = 3 + 4 * y</code> 这个表达式作为例子来进行介绍。</p>
<h2 id="1-1-AST"><a href="#1-1-AST" class="headerlink" title="1.1 AST"></a>1.1 AST</h2><p>抽象语法树（Abstract Syntax Tree，AST）是源代码的抽象语法结构的树状表示，树上的每个节点都表示源代码中的一种结构，之所以说是抽象的，是因为抽象语法树并不会表示出真实语法出现的每一个细节。</p>
<p>实际上，抽象语法树，其实就是用树状结构表示语法结构，也没有说必须是什么形式，只要能忠实地反映出源码的格式即可。在<a href="https://xie.infoq.cn/article/6f8ff63d6b88480c05f805d96%E4%B8%AD%EF%BC%8C%E7%AC%AC1.2%E8%8A%82%E4%B8%AD%EF%BC%8C%E5%B0%B1%E4%BB%8B%E7%BB%8D%E4%BA%86Yaml%E3%80%81XML%E5%92%8CGraphiz">https://xie.infoq.cn/article/6f8ff63d6b88480c05f805d96中，第1.2节中，就介绍了Yaml、XML和Graphiz</a> dot等几种格式，也有工具可以输出json格式的语法树结构，例如Coverity的CodeXM规则开发中，就支持先输出json格式的语法树给规则开发提供支持。</p>
<p>当然，一般资料中在进行介绍时，都是以操作符作为根节点，画个树状的结构来表示，这里咱们也简单画一个意思一下，如下图：</p>
<p><img src="/2022/10/24/program-representation-ast-ssa/ast.png" alt="AST示例"></p>
<div align="center">图1.1 AST示例</div>

<h2 id="1-2-三地址码"><a href="#1-2-三地址码" class="headerlink" title="1.2 三地址码"></a>1.2 三地址码</h2><p>三地址码是一种有意思的中间表示，当前也是编译原理中用得最火的。这里我给大家梳理一种我的理解上的概念，那就是，<strong>刨掉赋值操作，最多只有一个操作符</strong>，先看下面的几个例子：</p>
<ul>
<li>x &#x3D; y bop z</li>
<li>x &#x3D; uop y</li>
<li>x &#x3D; y</li>
<li>goto L</li>
</ul>
<p>如上，第一个，除了赋值之外，只有 <code>bop</code> 一个操作符，第二个，只有 <code>uop</code> 一个操作符，第三个没有操作符，同时，操作符的概念可以进一步扩展到函数调用等，例如 <code>call fun(a, b, c, d)</code>，虽然有四个操作数，但是我们认为 call fun只是一个操作符。</p>
<p>如上面 <code>x = 3 + 4 * y</code> 转换为三地址码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">t1 = 4</span><br><span class="line">t2 = y</span><br><span class="line">t3 = t1 * t2</span><br><span class="line">t4 = 3</span><br><span class="line">t5 = t4 + t3</span><br><span class="line">x = t5</span><br></pre></td></tr></table></figure>

<p>当然，有些形式下会减少临时变量的使用，尽量复用原来的变量或者常量，形成的三地址码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">t1 = 4 * y</span><br><span class="line">x = 3 + t1</span><br></pre></td></tr></table></figure>

<p>三地址码最初只是处理类似于 <code>x = y bop z</code> 这种形式的语句，而提出来的“三个操作数”的意思，随着语法的扩充，也并不是完全就是“三地址”。</p>
<h3 id="1-3-AST和三地址码对比"><a href="#1-3-AST和三地址码对比" class="headerlink" title="1.3 AST和三地址码对比"></a>1.3 AST和三地址码对比</h3><p>下面介绍几点AST和三地址码的对比特点：</p>
<ul>
<li>源码相关性</li>
</ul>
<p>AST中的节点与输入源代码中的各个语法元素一一对应，忠实地体现了源码的内容和语法特性，因此AST与源码强相关；三地址码就是从AST进一步抽象的一种中间表示，更接近机器语言，可以认为和语言无关，是连接前后端的一种中间表示。</p>
<ul>
<li>变化频繁程度</li>
</ul>
<p>因为AST需要忠实地体现出源代码的语法元素，因此在对应的编程语言升级时，对应的AST必然会跟着发生变化，比如Java，从Java7变成Java8，增加了大量的Lambda表达式、函数引用等特性，所以AST节点也需要增加这些语法节点，所以AST的版本需要随着语言发布而不断变化。</p>
<p>但是三地址码是一种经过处理的语言无关的中间表示，即使源代码结构变化，AST结构变化，但是转换后的三地址码是稳定的，不会经常发生变化，构造在三地址码上面的分析算法就相对比较稳定。</p>
<ul>
<li>结构</li>
</ul>
<p>AST体现源码的结构，需要匹配源码的语法，因此一般结构比较复杂，而三地址经过处理，一般比较紧凑，简单。例如，Java中，对 for，while，do while 有多种不同的循环方式，但是，其实内容大同小异，但是在AST层面，就是不一样的，但是转换为三地址码后，所表达的控制语义是完全一样的。</p>
<ul>
<li>表达信息</li>
</ul>
<p>AST表达了源码的信息，因此可以在AST上做程序结构的检查，但是三地址码中，可以更好地包含了程序控制流和数据流信息，能进行更深层次的流敏感分析，过程间分析，上下文敏感分析和对象敏感分析等等，从而实现各种更高难度的程序漏洞检查。</p>
<p>同时，三地址码因为是语言无关的， 所以在部分静态代码分析工具实现时，会对不同的三地址码，实现一个分析引擎，只是通过开发不同语言的规则，实现对不同语言的能力的覆盖，而AST是无法做到这一点的。因此，三地址码也被认为是静态代码分析的基础。</p>
<h2 id="2-SSA形式"><a href="#2-SSA形式" class="headerlink" title="2 SSA形式"></a>2 SSA形式</h2><h3 id="2-1-SSA概念及分类"><a href="#2-1-SSA概念及分类" class="headerlink" title="2.1 SSA概念及分类"></a>2.1 SSA概念及分类</h3><h4 id="2-1-1-SSA概念"><a href="#2-1-1-SSA概念" class="headerlink" title="2.1.1 SSA概念"></a>2.1.1 SSA概念</h4><p>SSA（Static Single Assignment，静态单赋值），顾名思义，就是每个变量只有唯一的赋值。以下面的代码举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        y = x + <span class="number">4</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> y + <span class="number">3</span>;</span><br><span class="line">    System.out.println(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下图为例，左图是原始代码，里面有分支， y 变量在不同路径中有不同赋值，最后打印 z的值。右图是等价的 SSA 形式，y 变量在两个分支中被改写为 y2, y3，在控制流交汇处插入φ函数，合并了来自不同边的 y2, y3值, 赋给 y4 最后z由y4生成。</p>
<p><img src="/2022/10/24/program-representation-ast-ssa/basic_ssa.png"></p>
<div align="center">图2-1 原始代码与 SSA 形式及相应 CFG 控制流图</div>

<p>其实要讲SSA形式，就不能离开对DU Chain（Define-Use Chain）和UD Chain（Use-Define Chain）的介绍，因为很多地方对SSA的概念的介绍，都是从DU Chain和UD Chain引起的。Use-Define Chain 是一个数据结构，包含一个Define变量，以及它的全部Use的集合。相对的，Define-Use Chain 包含一个Use变量，以及它的全部 Define的集合。</p>
<p>另外一种SSA的描述，就是在 Define-Use Chain中，每一个Use变量，只会有一个Define，例如，在前面例子中，<code>z = y + 3</code> 中，因为此时 y可能在两个分支中赋值，因此，对于变量 <code>z = y + 3</code> 中，y 的Use来说，有两个 Define，但是，通过更改为 SSA形式，<code>z = y + 3</code> 中，y只有一个 Define，那就是 y4。因此，通过将三地址码转为SSA形式，可以很大程度上，简化Use-Define Chain和Define-Use Chain。</p>
<h4 id="2-1-2-SSA分类"><a href="#2-1-2-SSA分类" class="headerlink" title="2.1.2 SSA分类"></a>2.1.2 SSA分类</h4><p>SSA 有几种不同分类（主要是最小SSA、剪枝SSA、半剪枝SSA，另外两种严格SSA和最大SSA，大部分资料上都没有看到，只是在少部分资料中有见到，所以简单提一下）：</p>
<ul>
<li>最小 SSA</li>
</ul>
<p>最小SSA有以下特点：同一原始名字的两个不同定义的路径汇合处都插入一个φ函数。这样得到符合两大特征的且拥有最少φ函数数量的 SSA 形式。但是这里的最小不包含优化效果，比如死代码消除。如上面图2.1节，就是一个最小SSA形式。</p>
<ul>
<li>剪枝 SSA</li>
</ul>
<p>如果变量在基本块的入口处不是活跃 (live) 的，就不必插入φ函数。一种方法是在插入 φ函数的时候计算活跃变量分析。另一种剪枝方式是在最小SSA上做死代码消除，删掉多余的φ函数。如下面的例子，y在分支执行完后，在最后的BB块中不再使用，y已经不再活跃，此时没必要在这个节点添加φ函数，如下面右图红色标出来的位置（说明：虽然不是剪枝SSA，但是仍然是最小SSA）。</p>
<p><img src="/2022/10/24/program-representation-ast-ssa/min_ssa.png"></p>
<div align="center">图2.2 剪枝SSA和最小SSA说明</div>

<ul>
<li>半剪枝 SSA</li>
</ul>
<p>鉴于剪枝 SSA 的成本，可以稍微折衷一点。插入φ函数前先去掉非跨越基本块的变量名。这样既减少了名字空间也没有计算活跃变量集的开销。如下图所示，y变量除了Define，并没有Use，所以，变量y其实可以去掉，如下右图：</p>
<p><img src="/2022/10/24/program-representation-ast-ssa/half_scissor_ssa.png"></p>
<div align="center">图2.3 半剪枝SSA形式</div>

<ul>
<li>严格 SSA</li>
</ul>
<p>如果一个 SSA中，每个Use被其Define支配（如果从程序入口到一个结点 A 的所有路径，都先经过结点B，则称A被B支配），那么称为严格 SSA（实际上，在强类型语言中，这种情况比较少，因为没有定义，就不允许使用，在少数动态类型语言中，允许没有定义就可以使用的才有这类问题）。</p>
<ul>
<li>最大SSA</li>
</ul>
<p>最大SSA是相对最小SSA而言的，就是在每个汇合点处为每个变量放置一个φ函数。很显然，这种方法会导致SSA的使用效率最差，用户体验也很差，我估计谁生成的SSA是这样的形式，会被使用的人打死的。</p>
<h3 id="2-2-SSA形式和普通三地址码对比"><a href="#2-2-SSA形式和普通三地址码对比" class="headerlink" title="2.2 SSA形式和普通三地址码对比"></a>2.2 SSA形式和普通三地址码对比</h3><p>其实对比SSA形式和普通的三地址码形式，只有一个区别，那就是，SSA形式，对于每个Use，只会有一个Define。两者在一定程度上，还是非常类似的。那么主要对比在于两种形式的各自的优缺点：</p>
<ul>
<li>SSA形式相对于三地址码，会引入大量的额外的临时变量，同时需要插入φ函数，还需要维护这些临时变量到原始变量的映射关系（当然，仁者见仁，智者见智，也有资料觉得这些额外的临时变量可以忽略，驳斥这个观点为谬论，不过的确还是有其不舒服的地方的）；</li>
<li>SSA形式的优势在于，SSA形式简化了DU Chain和UD chain，构建了一种稀疏结构，可以简化数据流分析（一般基于三地址码，需要基于传统的数据流分析来进行分析，称为dense分析，基于SSA形式，可以构造值依赖关系，基于值流分析，也称为sparse分析，同时，SSA形式也隐含了一定的程序流信息）。</li>
<li>SSA形式相比于普通三地址码，可以优化常量传播、值依赖分析、死代码、重复代码删除等；</li>
</ul>
<h2 id="3-CFG、基本块"><a href="#3-CFG、基本块" class="headerlink" title="3. CFG、基本块"></a>3. CFG、基本块</h2><p>这里简单介绍基本块和CFG的概念，对于如何构造基本块和CFG，会在后面进行介绍（这里强调一点：我个人倾向于将CFG和基本块等概念，当做中间表示的一部分，因为在很多开发实践中，将CFG、基本块的构造，和三地址码的生成，放在相同阶段，并且都是分析的输入，当然也有资料将CFG和基本块不当做中间表示的一部分，而当做中间表示在分析前的预处理，不过怎么理解都行，没有太大关系）。</p>
<h3 id="3-1-基本块（Basic-Block）"><a href="#3-1-基本块（Basic-Block）" class="headerlink" title="3.1 基本块（Basic Block）"></a>3.1 基本块（Basic Block）</h3><p>基本块由一系列的语句组成，这些语句具有如下特点：</p>
<ul>
<li>只能从第一条语句进入该基本块，不能够以某种方式跳入该基本块的中间;</li>
<li>基本块内的语句在执行时必须从最后一条语句离开，不能够执行到一半跳转到其它的基本块;</li>
<li>基本块内的语句序列，必须按照顺序依次执行。</li>
</ul>
<p>即对于一个基本块来说：只能有唯一一个进入点（基本块第一条语句）和唯一的一个出口（基本块最后一条语句），并且内部必须顺序执行，不能有分支和跳转。</p>
<h3 id="3-2-CFG"><a href="#3-2-CFG" class="headerlink" title="3.2 CFG"></a>3.2 CFG</h3><p>CFG是一个由基本块组成的有向图，每个节点都是一个基本块。如果程序的执行路径可能从一个基本块B1进入另一个基本块B2，B1有一条指向B2的边。</p>
<p>CFG可以用一个三元式描述：<code>G=(N, E, n0)</code></p>
<p>其中：</p>
<ul>
<li>N：表示所有基本块节点的集合；</li>
<li>E：表示所有边的集合；</li>
<li>n0：表示首节点。</li>
</ul>
<p>CFG具有如下的两条性质：</p>
<ul>
<li>CFG 必然有唯一的一个入口点；</li>
<li>首节点必然支配CFG中其他的所有节点（即从首节点到CFG上其他任何一个节点都有一条路可以连通）。</li>
</ul>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>本文介绍了一些静态代码分析中，中间表示的一些基本概念。</p>
<p>首先介绍了AST，AST忠实体现源码的结构，可以应用于程序结构检测、程序风格检查等检查；</p>
<p>其次，介绍了三地址码、SSA形式的三地址码，随后介绍了基本块和CFG，基本块就是一系列符合条件的三地址码指令的集合，CFG是一系列基本块按照一定依赖关系组合起来的。</p>
<p>基于CFG的中间表示，可以应用于程序的数据流分析、控制流分析等，是程序静态代码分析的基础。</p>
]]></content>
      <categories>
        <category>程序分析</category>
        <category>程序表示</category>
        <category>程序表示概述</category>
      </categories>
      <tags>
        <tag>AST</tag>
        <tag>SSA</tag>
        <tag>三地址码</tag>
        <tag>CFG</tag>
        <tag>BasicBlock</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】JavaParser应用介绍</title>
    <url>/2022/10/25/program-representation-javaparser-intro/</url>
    <content><![CDATA[<p><strong>说明</strong>：本文是作者首发在 infoq 上的原创文章，原文链接是：<a href="https://xie.infoq.cn/article/6f8ff63d6b88480c05f805d96">https://xie.infoq.cn/article/6f8ff63d6b88480c05f805d96</a></p>
<h2 id="0-Java-Parser-基本信息"><a href="#0-Java-Parser-基本信息" class="headerlink" title="0. Java Parser 基本信息"></a>0. Java Parser 基本信息</h2><p>Java Parser 是当前应用的最火的 Java Parser 工具，当前 GitHub 上，该开源项目已经有 3.4k star，而且协议非常友好，可以应用到商用工具上面，因此使用率非常高。</p>
<p>Java Parser 是基于 JavaCC 做为 Java 语言词法解析的工具，支持 Java 语言生成 AST，在 AST 基础上进行类型推断分析，支持修改 AST 从而生成新的 Java 文件内容，支持从 Java 1.0 到 14 所有的版本的 AST 解析。</p>
<span id="more"></span>

<p>Java Parser 的组件架构（<a href="https://javaparser.org/code-style-architecture/%EF%BC%89%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA%EF%BC%9A">https://javaparser.org/code-style-architecture/）如下图所示：</a></p>
<p><img src="/2022/10/25/program-representation-javaparser-intro/javaparser.png"></p>
<center>图 0-1 Java Parser 组件架构</center>

<p>本文讨论 Java Parser 面向 Java 规范检查方向的一些内容，因此我们不关心 Java Parser 在修改 AST 和重新生成 Java 文件方面的作用，着重介绍在生成 AST、AST 遍历、解析、类型推断及应用。</p>
<p>说明：本文中所有的代码的完成代码，可以参考<a href="https://gitee.com/maijun/javaparser-test/tree/master">https://gitee.com/maijun/javaparser-test/tree/master</a>(<font color="red">暂时下线，待优化上线</font>)。</p>
<h2 id="1-Java-Parser-AST-生成及打印"><a href="#1-Java-Parser-AST-生成及打印" class="headerlink" title="1. Java Parser AST 生成及打印"></a>1. Java Parser AST 生成及打印</h2><h3 id="1-1-Java-Parser-生成-AST"><a href="#1-1-Java-Parser-生成-AST" class="headerlink" title="1.1 Java Parser 生成 AST"></a>1.1 Java Parser 生成 AST</h3><p>Java Parser 转换生成 AST，有很多方法，主要支持两大类方式：</p>
<h4 id="1-输入为文件"><a href="#1-输入为文件" class="headerlink" title="1) 输入为文件"></a>1) 输入为文件</h4><p>输入为文件，即针对完整的文件为输入，生成整个文件的 AST（对于 Java 来说，如果是整个 Java 文件，AST 的根节点为 CompilationUnit），这种方式，可以完整保留源码的代码行信息，这样方便进行分析。对于文件为输入，即输入文件路径（多种写法，例如 String、File、Path、Resource 等，其实都是表示文件路径），同时可以指定文件的编码方式，下面的用例，指定的是 nio 的 Path 格式的路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 转换的是完整的Java文件</span></span><br><span class="line"><span class="type">File</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">relativePath</span> <span class="operator">=</span> <span class="string">&quot;test-case/javaparser-testcase/src/main/java/zmj/test/thread/MyThread.java&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">absolutePath</span> <span class="operator">=</span> base.getCanonicalPath() + File.separator + relativePath;</span><br><span class="line">ParseResult&lt;CompilationUnit&gt; result = <span class="keyword">new</span> <span class="title class_">JavaParser</span>().parse(Paths.get(absolutePath));</span><br><span class="line">result.getResult().ifPresent(YamlPrinter::print);</span><br></pre></td></tr></table></figure>

<h4 id="2-输入为代码片段"><a href="#2-输入为代码片段" class="headerlink" title="2) 输入为代码片段"></a>2) 输入为代码片段</h4><p>输入为代码片段时，一定要是一种标准的符合一定格式的能够识别为语句或者表达式的代码片段，例如 <code>int x</code> 是一个 VariableDeclarationExpr，<code>x = 3</code> 是一个 AssignExpr，但是，如果代码片段写成 <code>x + 3 = y</code>，则不符合基本的 Java 的语法。</p>
<p>下面是一个基本的关于这种用法的例子（如果要看完整支持的功能，可以看 Java Parser 的 API 文档）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. 转换的为部分代码片段</span></span><br><span class="line">ParseResult&lt;VariableDeclarationExpr&gt; exprResult = <span class="keyword">new</span> <span class="title class_">JavaParser</span>().parseVariableDeclarationExpr(<span class="string">&quot;int x = 3&quot;</span>);</span><br><span class="line">System.out.println(exprResult.getResult().get());</span><br><span class="line">exprResult.getResult().ifPresent(YamlPrinter::print);</span><br></pre></td></tr></table></figure>

<p>事实上，我们可以将完整的 Java 文件内容都读到一个字符串里面，然后传递给 Java Parser，来获取 AST，即针对完整的 Java 文件，以代码片段的方式来解析获取 AST，这样也是可以的。但是我们不推荐这样做，因为直接传递文件，可以保留完整的代码行信息，但是传递的如果是代码片段，则代码行信息被丢失掉了。</p>
<h3 id="1-2-Java-Parser-AST-打印"><a href="#1-2-Java-Parser-AST-打印" class="headerlink" title="1.2 Java Parser AST 打印"></a>1.2 Java Parser AST 打印</h3><p>Java Parser AST 打印有多种方式，当前支持三种打印方式：Yaml、XML 和 Graphiz 可以识别的 dot 的图片生成的格式。</p>
<p>如下面的代码所示，我们针对一个简单的语句（<code>x = 3 + 4</code>），生成了 Yaml、XML 和 Graphiz dot 的输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AstPrinter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ParseResult&lt;AssignExpr&gt; exprResult = <span class="keyword">new</span> <span class="title class_">JavaParser</span>().parseExpression(<span class="string">&quot;x = 3 + 4&quot;</span>);</span><br><span class="line">        Optional&lt;AssignExpr&gt; expr = exprResult.getResult();</span><br><span class="line">        <span class="comment">// 1. Yaml格式输出打印</span></span><br><span class="line">        expr.ifPresent(YamlPrinter::print);</span><br><span class="line">        <span class="comment">// 2. XML格式输出打印</span></span><br><span class="line">        expr.ifPresent(XmlPrinter::print);</span><br><span class="line">        <span class="comment">// 3. dot打印(可以通过Graphiz dot命令，将输出生成为图片格式，例如 dot -Tpng ast.dot &gt; ast.png)</span></span><br><span class="line">        expr.ifPresent(e -&gt; System.out.println(<span class="keyword">new</span> <span class="title class_">DotPrinter</span>(<span class="literal">true</span>).output(e)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-Yaml-格式输出"><a href="#1-Yaml-格式输出" class="headerlink" title="1) Yaml 格式输出"></a>1) Yaml 格式输出</h4><p>输出的 Yaml 格式如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">root(Type=AssignExpr):</span></span><br><span class="line">    <span class="attr">operator:</span> <span class="string">&quot;ASSIGN&quot;</span></span><br><span class="line">    <span class="string">target(Type=NameExpr):</span></span><br><span class="line">        <span class="string">name(Type=SimpleName):</span></span><br><span class="line">        <span class="attr">identifier:</span> <span class="string">&quot;x&quot;</span></span><br><span class="line">    <span class="string">value(Type=BinaryExpr):</span></span><br><span class="line">        <span class="attr">operator:</span> <span class="string">&quot;PLUS&quot;</span></span><br><span class="line">        <span class="string">left(Type=IntegerLiteralExpr):</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line">        <span class="string">right(Type=IntegerLiteralExpr):</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<h4 id="2-XML-格式输出"><a href="#2-XML-格式输出" class="headerlink" title="2) XML 格式输出"></a>2) XML 格式输出</h4><p>输出的 XML 格式如下（原始输出是只有一个字符串，这里我简单进行了处理，添加了换行和缩进）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">type</span>=<span class="string">&#x27;AssignExpr&#x27;</span> <span class="attr">operator</span>=<span class="string">&#x27;ASSIGN&#x27;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">target</span> <span class="attr">type</span>=<span class="string">&#x27;NameExpr&#x27;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span> <span class="attr">type</span>=<span class="string">&#x27;SimpleName&#x27;</span> <span class="attr">identifier</span>=<span class="string">&#x27;x&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span> <span class="attr">type</span>=<span class="string">&#x27;BinaryExpr&#x27;</span> <span class="attr">operator</span>=<span class="string">&#x27;PLUS&#x27;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">left</span> <span class="attr">type</span>=<span class="string">&#x27;IntegerLiteralExpr&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;3&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">left</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">right</span> <span class="attr">type</span>=<span class="string">&#x27;IntegerLiteralExpr&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;4&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">right</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-Graphiz-dot-输出"><a href="#3-Graphiz-dot-输出" class="headerlink" title="3) Graphiz dot 输出"></a>3) Graphiz dot 输出</h4><p>首先打印的内容如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">digraph &#123;</span><br><span class="line">n0 [label=&quot;root (AssignExpr)&quot;];</span><br><span class="line">n1 [label=&quot;operator=&#x27;ASSIGN&#x27;&quot;];</span><br><span class="line">n0 -&gt; n1;</span><br><span class="line">n2 [label=&quot;target (NameExpr)&quot;];</span><br><span class="line">n0 -&gt; n2;</span><br><span class="line">n3 [label=&quot;name (SimpleName)&quot;];</span><br><span class="line">n2 -&gt; n3;</span><br><span class="line">n4 [label=&quot;identifier=&#x27;x&#x27;&quot;];</span><br><span class="line">n3 -&gt; n4;</span><br><span class="line">n5 [label=&quot;value (BinaryExpr)&quot;];</span><br><span class="line">n0 -&gt; n5;</span><br><span class="line">n6 [label=&quot;operator=&#x27;PLUS&#x27;&quot;];</span><br><span class="line">n5 -&gt; n6;</span><br><span class="line">n7 [label=&quot;left (IntegerLiteralExpr)&quot;];</span><br><span class="line">n5 -&gt; n7;</span><br><span class="line">n8 [label=&quot;value=&#x27;3&#x27;&quot;];</span><br><span class="line">n7 -&gt; n8;</span><br><span class="line">n9 [label=&quot;right (IntegerLiteralExpr)&quot;];</span><br><span class="line">n5 -&gt; n9;</span><br><span class="line">n10 [label=&quot;value=&#x27;4&#x27;&quot;];</span><br><span class="line">n9 -&gt; n10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上面的内容写入 ast.dot 文件中，使用命令 dot -Tpng ast.dot &gt; ast.png 即可得到一个图片，如下：</p>
<p><img src="/2022/10/25/program-representation-javaparser-intro/javaparser-dot.png"></p>
<p>差不多算是一个 AST 的树状结构的一个样子了。</p>
<h2 id="2-Java-Parser-AST-遍历"><a href="#2-Java-Parser-AST-遍历" class="headerlink" title="2. Java Parser AST 遍历"></a>2. Java Parser AST 遍历</h2><p>在 Java Parser 中，AST 的遍历采用的是访问者模式，在访问者模式的基础上，增加了一个简单的包装器（这里就不再介绍什么是访问者模式和包装器模式了，在另外一篇文章里面，有关于访问者模式的详细介绍）。下面代码中定义了两个非常简单的 visitor，其中一个访问函数调用表达式，打印所有的函数调用的代码，第二个访问所有的函数定义信息，将当前类中定义的函数都打印出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestVisitor</span> <span class="keyword">extends</span> <span class="title class_">GenericVisitorAdapter</span>&lt;Void, Void&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Void <span class="title function_">visit</span><span class="params">(MethodCallExpr n, Void arg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function call: &quot;</span> + n.toString());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.visit(n, arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Void <span class="title function_">visit</span><span class="params">(MethodDeclaration n, Void arg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function declaration: &quot;</span> + n.getNameAsString());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.visit(n, arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：一个非常重要的地方，每个 visit 方法写完，都需要调用 <code>super.visit(n,arg)</code>; 因为在基类是一个包装器，实现了节点的遍历，如果不调用，当前节点处理完，程序就结束了。</p>
<h2 id="3-Java-Parser-类型推断"><a href="#3-Java-Parser-类型推断" class="headerlink" title="3. Java Parser 类型推断"></a>3. Java Parser 类型推断</h2><h4 id="3-1-Symbol-Solver"><a href="#3-1-Symbol-Solver" class="headerlink" title="3.1 Symbol Solver"></a>3.1 Symbol Solver</h4><p>在 Java 中，所有的 Name 等都被称为 Symbol，包括变量、类型、方法等。一般提到类型推断，就是对 Symbol 的操作。所以我们这里提一下 Symbol Solver，因为所有的 Type Solver 都是针对特定的 Symbol 工作的（即 TypeSolver 需要封装在 SymbolSolver 中才能工作）。</p>
<h4 id="3-2-Type-Solver"><a href="#3-2-Type-Solver" class="headerlink" title="3.2 Type Solver"></a>3.2 Type Solver</h4><p>Java Parser 类型推断有多种类型推断方式，如下表：</p>
<ul>
<li>AarTypeSolver: 在 Android aar 文件中查找特定的类型;</li>
<li>ClassLoaderTypeSolver: 针对自定义的 ClassLoader 使用，可以处理由该 ClassLoader 加载的类，这种类型在静态代码分析中很少用到;</li>
<li>CombinedTypeSolver: 可以封装多个 Type Solver 一起使用</li>
<li>JarTypeSolver: 在 Jar 文件中，查找特定的类型</li>
<li>JavaParserTypeSolver: 在源码中查找特定的类型，只需要传递源码根路径即可</li>
<li>MemoryTypeSolver: 一般不需要使用，可以在测试中使用</li>
<li>ReflectionTypeSolver: 用来处理应用 classpath 里面的类，一般用于处理 JRE 中的类</li>
</ul>
<p>下面介绍一个简单的例子（这个是一个简单的 maven 工程，但是为了测试 jar 的依赖，我先收集所有依赖的 jar 到项目下面的一个路径下，执行的命令为：<code>mvn dependency:copy-dependencies -DoutputDirectory=lib</code>）。</p>
<p>这一个普通的 Java 应用，需要处理的类型有三个来源：① 当前自己工程中定义；② 当前工程的第三方依赖；③ JRE 中的基本类型。对应上面的 JavaParserTypeSolver，JarTypeSolver 和 ReflectionTypeSolver，组合成一个 CombinedTypeSolver，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CombinedTypeSolver <span class="title function_">generateTypeSolver</span><span class="params">(String sourcePath, String libPath)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">CombinedTypeSolver</span> <span class="variable">solver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CombinedTypeSolver</span>();</span><br><span class="line">    <span class="comment">// 1. JavaParserTypeSolver</span></span><br><span class="line">    solver.add(<span class="keyword">new</span> <span class="title class_">JavaParserTypeSolver</span>(sourcePath));</span><br><span class="line">    <span class="comment">// 2. JarTypeSolver</span></span><br><span class="line">    <span class="type">FindFileVisitor</span> <span class="variable">findJarVisitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FindFileVisitor</span>(<span class="string">&quot;.jar&quot;</span>);</span><br><span class="line">    Files.walkFileTree(Paths.get(libPath), findJarVisitor);</span><br><span class="line">    <span class="keyword">for</span> (String name : findJarVisitor.getFileNameList()) &#123;</span><br><span class="line">        solver.add(<span class="keyword">new</span> <span class="title class_">JarTypeSolver</span>(name));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. ReflectionTypeSolver</span></span><br><span class="line">    solver.add(<span class="keyword">new</span> <span class="title class_">ReflectionTypeSolver</span>());</span><br><span class="line">    <span class="keyword">return</span> solver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后构造的 TypeSolver 传递给 JavaParser：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TypeSolver</span> <span class="variable">typeSolver</span> <span class="operator">=</span> generateTypeSolver(base.getCanonicalPath() + File.separator + sourcePath,</span><br><span class="line">                            base.getCanonicalPath() + File.separator + libPath);</span><br><span class="line"><span class="type">JavaSymbolSolver</span> <span class="variable">symbolSolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavaSymbolSolver</span>(typeSolver);</span><br><span class="line"><span class="type">ParserConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParserConfiguration</span>();</span><br><span class="line">configuration.setSymbolResolver(symbolSolver);</span><br><span class="line"><span class="type">JavaParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavaParser</span>(configuration);</span><br></pre></td></tr></table></figure>

<p>下面介绍三类主要的类型处理内容：</p>
<ul>
<li>对变量（表达式）类型的推断</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析变量的类型定义</span></span><br><span class="line">System.out.println(<span class="string">&quot;----&gt; resolve variable type&quot;</span>);</span><br><span class="line">mce.getScope().ifPresent(expression -&gt; &#123;</span><br><span class="line">    <span class="type">ResolvedType</span> <span class="variable">resolvedType</span> <span class="operator">=</span> expression.calculateResolvedType();</span><br><span class="line">    System.out.println(expression.toString() + <span class="string">&quot; is a: &quot;</span> + resolvedType);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>用例的部分结果输出：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">-------------------------------------</span><br><span class="line">System.out.println(&quot;Hello World!&quot;)</span><br><span class="line">----&gt; resolve variable type</span><br><span class="line">System.out is a: ReferenceType&#123;java.io.PrintStream, typeParametersMap=TypeParametersMap&#123;nameToValue=&#123;&#125;&#125;&#125;</span><br><span class="line">-------------------------------------</span><br><span class="line">m.start()</span><br><span class="line">----&gt; resolve variable type</span><br><span class="line">m is a: ReferenceType&#123;zmj.test.thread.MyThread, typeParametersMap=TypeParametersMap&#123;nameToValue=&#123;&#125;&#125;&#125;</span><br><span class="line">-------------------------------------</span><br><span class="line">HashBasedTable.create()</span><br><span class="line">----&gt; resolve variable type</span><br><span class="line">HashBasedTable is a: ReferenceType&#123;com.google.common.collect.HashBasedTable, typeParametersMap=TypeParametersMap&#123;nameToValue=&#123;com.google.common.collect.HashBasedTable.V=TypeVariable &#123;JavassistTypeParameter&#123;V&#125;&#125;, com.google.common.collect.HashBasedTable.R=TypeVariable &#123;JavassistTypeParameter&#123;R&#125;&#125;, com.google.common.collect.HashBasedTable.C=TypeVariable &#123;JavassistTypeParameter&#123;C&#125;&#125;&#125;&#125;&#125;</span><br><span class="line">-------------------------------------</span><br><span class="line">tt.put(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</span><br><span class="line">----&gt; resolve variable type</span><br><span class="line">tt is a: ReferenceType&#123;com.google.common.collect.Table, typeParametersMap=TypeParametersMap&#123;nameToValue=&#123;com.google.common.collect.Table.C=ReferenceType&#123;java.lang.String, typeParametersMap=TypeParametersMap&#123;nameToValue=&#123;&#125;&#125;&#125;, com.google.common.collect.Table.V=ReferenceType&#123;java.lang.String, typeParametersMap=TypeParametersMap&#123;nameToValue=&#123;&#125;&#125;&#125;, com.google.common.collect.Table.R=ReferenceType&#123;java.lang.String, typeParametersMap=TypeParametersMap&#123;nameToValue=&#123;&#125;&#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如上，可以计算诸如表达式（System.out）、变量（m，tt）、静态类（HashBasedTable）等的类型，而且支持第三方库的类型推断（HashBasedTable 为 google guava 库中的类型）。</p>
<ul>
<li>对函数签名的推断</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析函数调用的函数声明</span></span><br><span class="line">System.out.println(<span class="string">&quot;----&gt; resolve method declaration&quot;</span>);</span><br><span class="line"><span class="type">JavaParserFacade</span> <span class="variable">javaParserFacade</span> <span class="operator">=</span> JavaParserFacade.get(typeSolver);</span><br><span class="line">SymbolReference&lt;ResolvedMethodDeclaration&gt; resolvedMethodDeclarationSymbolReference = javaParserFacade.solve(mce);</span><br><span class="line">System.out.println(<span class="string">&quot;is resolved: &quot;</span> + resolvedMethodDeclarationSymbolReference.isSolved());</span><br><span class="line">System.out.println(<span class="string">&quot;resolved type&quot;</span> + resolvedMethodDeclarationSymbolReference.getCorrespondingDeclaration());</span><br></pre></td></tr></table></figure>

<p>如上，为了对函数签名进行推断，需要先构造出来一个 JavaParserFacade 对象，也是通过 typeSolver 构造出来的。上面的部分输出如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">-------------------------------------</span><br><span class="line">System.out.println(&quot;Hello World!&quot;)</span><br><span class="line">----&gt; resolve method declaration</span><br><span class="line">is resolved: true</span><br><span class="line">resolved typeReflectionMethodDeclaration&#123;method=public void java.io.PrintStream.println(java.lang.String)&#125;</span><br><span class="line">-------------------------------------</span><br><span class="line">m.start()</span><br><span class="line">----&gt; resolve method declaration</span><br><span class="line">is resolved: true</span><br><span class="line">resolved typeReflectionMethodDeclaration&#123;method=public synchronized void java.lang.Thread.start()&#125;</span><br><span class="line">-------------------------------------</span><br><span class="line">HashBasedTable.create()</span><br><span class="line">----&gt; resolve method declaration</span><br><span class="line">is resolved: true</span><br><span class="line">resolved typeJavassistMethodDeclaration&#123;ctMethod=javassist.CtMethod@6c8156fd[public static create ()Lcom/google/common/collect/HashBasedTable;]&#125;</span><br><span class="line">-------------------------------------</span><br><span class="line">tt.put(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</span><br><span class="line">----&gt; resolve method declaration</span><br><span class="line">is resolved: true</span><br><span class="line">resolved typeJavassistMethodDeclaration&#123;ctMethod=javassist.CtMethod@f9f9cbbc[public abstract put (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;]&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，对函数签名推断得非常准确，包括静态方法和实例方法，抽象、函数形参类型、返回值类型、函数所在的类等，都推断得非常准确。</p>
<ul>
<li>对类继承关系推断</li>
</ul>
<p>如下的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析类的继承关系</span></span><br><span class="line">System.out.println(<span class="string">&quot;---- resolve class extend relation&quot;</span>);</span><br><span class="line">cu.findAll(ClassOrInterfaceDeclaration.class).forEach(cid -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;current class: &quot;</span> + cid.getFullyQualifiedName().get());</span><br><span class="line">    NodeList&lt;ClassOrInterfaceType&gt; superTypes = cid.getExtendedTypes();</span><br><span class="line">    superTypes.forEach(type -&gt; System.out.println(<span class="string">&quot;super class: &quot;</span> + type.resolve()));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">---- resolve class extend relation</span><br><span class="line">current class: zmj.test.App</span><br><span class="line">---- resolve class extend relation</span><br><span class="line">current class: zmj.test.thread.MyThread</span><br><span class="line">super class: ReferenceType&#123;java.lang.Thread, typeParametersMap=TypeParametersMap&#123;nameToValue=&#123;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>当前只定义了两个类，一个是 App，没有定义父类（直接就是 Object），没有打印，MyThread 是一个线程，获取到了父类的类型。</p>
<h2 id="4-Java-Parser-简单应用"><a href="#4-Java-Parser-简单应用" class="headerlink" title="4. Java Parser 简单应用"></a>4. Java Parser 简单应用</h2><h3 id="4-1-源码间依赖关系分析"><a href="#4-1-源码间依赖关系分析" class="headerlink" title="4.1 源码间依赖关系分析"></a>4.1 源码间依赖关系分析</h3><p>如第 3.2 节中介绍的例子，可以非常方便地基于类型推断获取如下信息：</p>
<ul>
<li>当前类的父类或者父接口，并递归获取所有的父类和父接口；</li>
<li>获取当前所调用函数的 signature（函数签名，包含可以唯一识别一个方法的所有信息，例如所在的类、名字、形参类型列表、返回值类型），从而拿到函数调用关系；</li>
</ul>
<p>另外，再结合源码文件和 Java 类定义的对应关系，可以很方便地构造出工程的 CG 图，识别出源码之间的依赖关系分析。</p>
<h3 id="4-2-Java-代码度量"><a href="#4-2-Java-代码度量" class="headerlink" title="4.2 Java 代码度量"></a>4.2 Java 代码度量</h3><p>实际上，基于 Java Parser 获得的 AST 信息，辅助类型推断特性，可以实现针对源代码的各种度量内容。可以参考<a href="https://www.exida.com/Blog/software-metrics-iso-26262-iec-61508%EF%BC%8C">https://www.exida.com/Blog/software-metrics-iso-26262-iec-61508，</a> 查看常见的代码度量项。针对其中 3.1 所列出的所有的项都可以度量。</p>
<p>常见的一些度量项：</p>
<ul>
<li><p>针对函数：圈复杂度、代码深度、各类代码行信息、调用函数数量、被调用次数、其他诸如入参个数…；</p>
</li>
<li><p>针对文件：总代码行、空行、注释行、非空非注释行、代码注释密度…；</p>
</li>
<li><p>针对工程：文件总数、代码行总数、平均代码行…</p>
</li>
</ul>
<p>基于 Java Parser 可以很好地进行实现，而且大部分都不需要完整的依赖信息，可以方便地进行度量。</p>
<h3 id="4-3-Java-规范支持检查"><a href="#4-3-Java-规范支持检查" class="headerlink" title="4.3 Java 规范支持检查"></a>4.3 Java 规范支持检查</h3><p>当前，针对各类规范支持，可以在不同的层面上进行支持，例如直接对源码检查、对解析得到的 Token 进行检查、对 AST 进行检查、在 CFG 和 CG 上进行数据流检查和各种形式化检查等。</p>
<p>基于 Java Parser，可以实现在 AST 及源码（可以直接读取源码信息）、Token（从 AST 的节点可以获取当前 AST Node 中的所有的 Token）相结合的所有检查。</p>
<p>例如，PMD 主要是在 AST 上进行的检查，CheckStyle 主要是在 Token 和 AST 上进行的检查，结合类型推断的支持，Java Parser 可以实现比 PMD 和 CheckStyle 更精确的检查。</p>
]]></content>
      <categories>
        <category>程序分析</category>
        <category>程序表示</category>
        <category>AST解析与操作</category>
      </categories>
      <tags>
        <tag>JavaParser</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】访问者模式及其在 Java Parser 中的应用</title>
    <url>/2022/10/26/program-representation-visitor/</url>
    <content><![CDATA[<p><strong>说明</strong>：本文是作者首发在 infoq 上的原创文章，原文链接是：<a href="https://xie.infoq.cn/article/5f80da3c014fd69f8dbe09b28">https://xie.infoq.cn/article/5f80da3c014fd69f8dbe09b28</a></p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>访问者模式，是 Java 设计模式中广泛使用的一种设计模式，尤其是在 AST 的遍历中使用更加普遍。在静态代码分析中，有部分类型的缺陷，可以通过简单遍历 AST 结构完成，例如在 finally 中执行 return 操作，空的 catch 块等。很多静态代码分析工具，也就应用了这种设计模式，例如 Java 静态代码分析工具 PMD，而且，很多 AST 中间表示，已经直接对访问者模式进行了支持，例如 Eclipse JDT、JavaParser 等。</p>
<span id="more"></span>

<p>本文将首先介绍访问者模式的概念和相关知识，然后通过 JavaParser 的源码分析，介绍访问者模式具体的应用。</p>
<h2 id="2-访问者模式介绍"><a href="#2-访问者模式介绍" class="headerlink" title="2. 访问者模式介绍"></a>2. 访问者模式介绍</h2><h3 id="2-1-引例"><a href="#2-1-引例" class="headerlink" title="2.1 引例"></a>2.1 引例</h3><p>首先我们通过一个案例来引入对访问者模式的介绍。</p>
<p>杭州是一个美丽的城市，每年会有大量的游客到杭州过来游玩，美丽的西湖和香火鼎盛的灵隐寺都是游客必往之地。而对于美丽的西湖，又有断桥残雪、三潭印月等西湖十景，灵隐寺景区还有济公殿、大雄宝殿等不同的建筑。</p>
<p>我们假定每个游客到达杭州，就会游玩上面所有的地方，我们就可以针对这位游客的这次游玩进行打包操作，不需要对游玩断桥残雪进行特殊操作。我们应该怎么办呢？</p>
<p><img src="/2022/10/26/program-representation-visitor/hangzhou_visitor.png"></p>
<center>图 2.1 杭州游览路线</center>

<p>首先，对于上面每个地方，每个人都可能有不同的访问行为，有游客到济公殿会看看墙上济公的故事，有的游客可能就对济公殿很熟悉，进去拜一下就出来了，有的到了断桥残雪感慨一句全是人头，也有人到了断桥残雪，就会会回味一下张祜的诗句。</p>
<p>其次，对于上面每个地方，对于不同的游客来说，不确定，所以，不管是谁，给他准备个入口进来总不会有问题。</p>
<p>结合上面分析，我们可以初步分析访问者模式是怎么一回事儿：<strong>在每个游客自己内部，把对每个景点想操作的行为定义出来，然后在每个景点，准备个接口，把游客迎进来，最后呢，把这个游客迎进来之后呢，执行这个游客里面定义的，关于自己的行为</strong>。</p>
<p><img src="/2022/10/26/program-representation-visitor/hangzhou_visit_design.png"></p>
<center>图 2.2 访问者模式之游览杭州</center>

<ul>
<li><p>抽象访问者(Visitor，游客)角色：声明访问者可以访问哪些元素（景点），具体到程序中就是 visit 方法中的参数定义哪些对象是可以被访问的。该操作接口的名字和参数标识了发送访问请求给具体访问者的具体元素角色。这样访问者就可以通过该元素角色的特定接口直接访问它；</p>
</li>
<li><p>具体访问者(Concrete Visitor，张三和李四)角色：实现抽象访问者所声明的方法接口，也就是抽象访问者所声明的各个访问操作。它影响到访问者访问到一个对象（景点）后该干什么，要做什么事情；</p>
</li>
<li><p>抽象节点(Node，景点)角色：声明接受哪一类访问者访问，程序上是通过 accept 方法中的参数来定义的，该方法接受一个访问者对象作为一个参数。并且声明了在该节点上可以进行的操作；</p>
</li>
<li><p>具体元素(Concrete Element，三潭印月、济公殿等)角色：实现抽象节点类所声明的 accept 方法，通常都是 visitor.visit(this)，基本上已经形成一种定式了，并实现该具体节点上可以进行的操作；</p>
</li>
<li><p>结构对象(Object  Structure)角色：可以遍历结构中的所有元素；可以提供一个高层次的接口让访问者对象可以访问每一个元素；可以设计成一个复合对象或者一个聚集，例如 List，在我们实际静态代码分析中，是一个树形结构。</p>
</li>
</ul>
<h3 id="2-2-示例代码"><a href="#2-2-示例代码" class="headerlink" title="2.2 示例代码"></a>2.2 示例代码</h3><p>下面这部分贴出来上面示例的代码，为了方便对应，命名也都还采用了中文命名。</p>
<p>景点接口及其实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 景点 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(游客 visitor)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 杭州 implements 景点&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(游客 visitor)</span> &#123;</span><br><span class="line">        visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 西湖 implements 景点&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(游客 visitor)</span> &#123;</span><br><span class="line">        visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 断桥残雪 implements 景点&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(游客 visitor)</span> &#123;</span><br><span class="line">        visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 三潭印月 implements 景点&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(游客 visitor)</span> &#123;</span><br><span class="line">        visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 灵隐寺 implements 景点&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(游客 visitor)</span> &#123;</span><br><span class="line">        visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 大雄宝殿 implements 景点&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(游客 visitor)</span> &#123;</span><br><span class="line">        visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 济公殿 implements 景点&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(游客 visitor)</span> &#123;</span><br><span class="line">        visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问者接口及其实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 游客 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(杭州 景点)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(西湖 景点)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(三潭印月 景点)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(断桥残雪 景点)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(灵隐寺 景点)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(大雄宝殿 景点)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(济公殿 景点)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 张三游客 implements 游客 &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(杭州 景点)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;张三来到杭州&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(西湖 景点)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;张三来到西湖&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(三潭印月 景点)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;张三来到三潭印月&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(断桥残雪 景点)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;张三来到断桥残雪，人真多&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(灵隐寺 景点)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;张三来到灵隐寺&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(大雄宝殿 景点)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;张三来到大雄宝殿&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(济公殿 景点)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;张三来到济公殿&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 李四游客 implements 游客 &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(杭州 景点)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;李四来到杭州&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(西湖 景点)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;李四来到西湖&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(三潭印月 景点)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;李四来到三潭印月&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(断桥残雪 景点)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;李四来到断桥残雪，哈哈哈&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(灵隐寺 景点)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;李四来到灵隐寺&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(大雄宝殿 景点)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;李四来到大雄宝殿&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(济公殿 景点)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;李四来到济公殿&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>景点结构实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 景点结构 &#123;</span><br><span class="line">    <span class="comment">// 树形结构更能说明静态代码分析AST问题，也更能模拟该场景</span></span><br><span class="line">    <span class="comment">// 这里图省事儿，就拿一个List表示了</span></span><br><span class="line">    List&lt;景点&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitAll</span><span class="params">(游客 visitor)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(景点 node : nodes) &#123;</span><br><span class="line">            node.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(景点 node)</span> &#123;</span><br><span class="line">        nodes.add(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例代码入口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        景点结构 structure = <span class="keyword">new</span> 景点结构();</span><br><span class="line">        structure.add(<span class="keyword">new</span> 杭州());</span><br><span class="line">        structure.add(<span class="keyword">new</span> 西湖());</span><br><span class="line">        structure.add(<span class="keyword">new</span> 三潭印月());</span><br><span class="line">        structure.add(<span class="keyword">new</span> 断桥残雪());</span><br><span class="line">        structure.add(<span class="keyword">new</span> 灵隐寺());</span><br><span class="line">        structure.add(<span class="keyword">new</span> 大雄宝殿());</span><br><span class="line">        structure.add(<span class="keyword">new</span> 济公殿());</span><br><span class="line"></span><br><span class="line">        游客 zhangsanVisitor = <span class="keyword">new</span> 张三游客();</span><br><span class="line">        structure.visitAll(zhangsanVisitor);</span><br><span class="line"></span><br><span class="line">        游客 lisiVisitor = <span class="keyword">new</span> 李四游客();</span><br><span class="line">        structure.visitAll(lisiVisitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-基于包装器的访问者模式访问优化"><a href="#3-基于包装器的访问者模式访问优化" class="headerlink" title="3. 基于包装器的访问者模式访问优化"></a>3. 基于包装器的访问者模式访问优化</h2><p>上面介绍访问者模式时，我们构造了一个 List 类型的景点结构，然后在访问时，我们自己在景点结构中执行了遍历操作，遍历所有的节点，然后分别执行节点的 accept 方法，接受访客的访问。那么在结构很复杂的场景下，我们还适合这样遍历吗？下面，我们将切到我们主要想介绍的编程语言的 AST 遍历上，来讨论这个问题。</p>
<p>因为编程语言的语法结构，语法是固定的，但是，基于这些语法，却可以有非常多的实现，if 是一个 Statement，包含有 condition（条件）和实现的 body，而 body 又可以有非常多的 Statement 组成，当然就可以包含 if 语句。虽然当我们将一个文件，比如 Java 文件的 AST 完整构造出来，那么它的 AST 就已经确定了，然后我们就可以在 AST 中，使用 visitAll 来<strong>递归遍历</strong> AST 中所有的节点，包括每个节点的子节点，但是却非常麻烦。</p>
<p>在这里，我们来介绍一种基于包装器的优化访问者模式的访问的方法，这种方法，也是 JavaParser 中采用的。</p>
<p>首先，我们再拿前面的游客来杭州游玩来举例子，游客可以自己过来玩，当然就要自己设计游览路线，所有的事情都要自己做，但是同样，可以跟团来旅游啊！跟团过来旅游，就相当于创建了一个包装器，旅行团将整个旅游过程打包了，游客需要跟团走，然后在每个景点可以自己游玩。比如<strong>首先旅游团把游客带到断桥残雪，然后游客发出“全是人头”的感慨，然后再听导游介绍断桥残雪的典故，然后，有旅游团将你带到下一个景点（例如三潭音乐）</strong>，整个过程，游客只需要对自己行为进行定义，然后就是听旅游团安排。</p>
<p>其中：</p>
<ul>
<li><p>旅游团：就相当于一个包装类，对旅游的路线进行包装，也可以定义自己的旅游的行为，例如某些介绍，一般只做路径遍历（旅游路线）的规划；</p>
</li>
<li><p>游客：在包装器模式下，游客在实现好自己的 visit 行为之后，需要调用旅游团（即父类）的 visit 的行为，所以，一般我们写好 visit 方法，通常还要调用 super.visit 方法。</p>
</li>
</ul>
<p>这里包装器，只是一种简单的包装器模式，如果想详细了解包装器模式的使用，可以自己搜索相关资料。</p>
<h2 id="4-JavaParser-中访问者模式应用"><a href="#4-JavaParser-中访问者模式应用" class="headerlink" title="4. JavaParser 中访问者模式应用"></a>4. JavaParser 中访问者模式应用</h2><p>这里，我们通过实现一个检测空的 catch 块的功能，简单介绍如何自己定义访问器，并且介绍其中访问者模式和包装器模式的应用。在 JavaParser 中，Catch 块类型为 CatchClause。</p>
<p>首先，在 VoidVisitor 接口中，定义了一个访问访问 CatchClause 的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(CatchClause n, A arg)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，A 为泛型，表示可以传入的数据类型，我们简单示例，实现时，A 就为 Object。</p>
<p>然后，在包装器类中，定义了 VoidVisitorAdapter 中，定义了一个实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(<span class="keyword">final</span> CatchClause n, <span class="keyword">final</span> A arg)</span> &#123;</span><br><span class="line">    n.getBody().accept(<span class="built_in">this</span>, arg);</span><br><span class="line">    n.getParameter().accept(<span class="built_in">this</span>, arg);</span><br><span class="line">    n.getComment().ifPresent((l) -&gt; &#123;</span><br><span class="line">        l.accept(<span class="built_in">this</span>, arg);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，在包装器类中，对 CatchClause 依次获取所有的子节点，然后使用放弃访问器进行遍历（实际上，就是定义了遍历 AST 节点的路径，AST 是一种树状结构，依次访问每个节点的子节点，可以最终完成对整棵树的遍历）。</p>
<p>我们自己实现一个访问器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.github.javaparser.ast.stmt.CatchClause;</span><br><span class="line"><span class="keyword">import</span> com.github.javaparser.ast.stmt.Statement;</span><br><span class="line"><span class="keyword">import</span> com.github.javaparser.ast.visitor.VoidVisitorAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmptyCatchBlockRule</span> <span class="keyword">extends</span> <span class="title class_">VoidVisitorAdapter</span>&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(<span class="keyword">final</span> CatchClause n, <span class="keyword">final</span> Object arg)</span> &#123;</span><br><span class="line">        List&lt;Statement&gt; statements = n.getBody().getStatements();</span><br><span class="line">        <span class="keyword">if</span> (statements == <span class="literal">null</span> || statements.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;empty catch block found at line: &quot;</span> + n.getBegin().get().line);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>.visit(n, arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，因为我们只关心空的 Catch 块的问题，因此我们将只对 visit CatchClause 类型节点的实现，当当前访问器访问到我们自己没有实现的节点时，将直接调用包装器中的实现，而包装器实现的，就是获取所有的子节点来遍历，直到再次找到 CatchClause，来执行自己写的访问器实现。</p>
<p>当然，如第三部分的介绍，最后的 <code>super.visit(n, arg);</code> 语句是不可缺少的，因为 Catch 块中，仍然可以包含 Catch 块，如果我们在这部分没有调父类的 visit 方法，将导致当前 Catch 块中的子 Catch 块无法遍历到。</p>
<p>最后，我们写一个入口类，对此进行检查：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.github.javaparser.JavaParser;</span><br><span class="line"><span class="keyword">import</span> com.github.javaparser.ParseResult;</span><br><span class="line"><span class="keyword">import</span> com.github.javaparser.ast.CompilationUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sourcePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\workspace\\idea\\test\\scs-java\\src\\main\\java\\zmj\\cert\\analyze\\rule\\Test.java&quot;</span>;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(sourcePath);</span><br><span class="line">        ParseResult&lt;CompilationUnit&gt; result = <span class="keyword">new</span> <span class="title class_">JavaParser</span>().parse(in, Charset.defaultCharset());</span><br><span class="line">        <span class="keyword">if</span> (result.getResult().isPresent()) &#123;</span><br><span class="line">            result.getResult().get().accept(<span class="keyword">new</span> <span class="title class_">EmptyCatchBlockRule</span>(), <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们只需要对测试的代码（Test.java）整体生成 AST，然后调用 accept 方法，就可以完成对整棵树的遍历（遍历操作在包装器类中实现），上面代码执行完，结果如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">empty catch block found at line: 8</span><br></pre></td></tr></table></figure>

<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本文中，介绍了如下内容：</p>
<p>(1) 介绍了访问者模式的基本概念和思路，并结合案例，详细介绍了访问者模式的使用方法；</p>
<p>(2) 介绍了如何通过访问者模式，结合使用简单包装器模式，简化复杂元素结构的遍历；</p>
<p>(3) 介绍了 JavaParser 中，访问者模式的基本应用；</p>
<p>(4) 介绍了一个简单的 Java 缺陷的检查的代码，实际上，Java 静态代码分析工具 PMD，就是基于该思路进行的开发。</p>
<p>本文主要目的是介绍访问者模式在 JavaParser 中的应用，或者更进一步，介绍访问者模式如果在基于 AST 遍历的静态代码分析工具中的缺陷检查上的应用（只要是能够生成 AST 的语言，都可以有类似实现）。</p>
]]></content>
      <categories>
        <category>程序分析</category>
        <category>程序表示</category>
        <category>AST解析与操作</category>
      </categories>
      <tags>
        <tag>visitor设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>用于静态代码分析的程序表示——概述</title>
    <url>/2022/10/24/program-representation/</url>
    <content><![CDATA[<h2 id="1-程序的语法和语义"><a href="#1-程序的语法和语义" class="headerlink" title="1. 程序的语法和语义"></a>1. 程序的语法和语义</h2><p>对于现代编程语言，都有语法和语义两层含义，这里做个比较浅显的介绍。</p>
<h3 id="1-1-语法"><a href="#1-1-语法" class="headerlink" title="1.1 语法"></a>1.1 语法</h3><p>语法，就是代码怎么写的问题。比如 Java 中，可以写 <code>int z = x + y;</code>，就是不能写成 <code>int z = x y +</code>；当然，我们不排除某些语言，会把二元表达式，写成这种逆波兰式的写法，但是至少 Java 这种语言，是使用中缀表达式的写法。</p>
<span id="more"></span>

<p>放到我们的日常交流中，就是话怎么说的问题，比如 “你吃饭了没？”，不会说成“饭吃你了没？”。</p>
<p>我们在看编译原理相关的教材的时候，我们可以知道，程序的语法，是通过文法来进行实现的，并且编译原理中，有大量的篇幅，都在介绍文法（尤其是上下文无关文法）的知识。</p>
<p>这里，涉及到程序文法的内容，我们统统都不进行介绍。因为，程序分析虽然脱胎与编译原理，但是高于编译原理。<strong>在现实中，我们实现的静态代码分析工具，都是在程序编写正常，并且一般都可以正常运行的情况下使用的</strong>。我们实现的静态代码分析工具不需要从零开始构造。</p>
<p>通常，我们实现静态代码分析工具，并不太需要了解文法知识。我们可以直接通过 Antlr4 或者 javacc 等直接获取代码的解析树（具体语法树），当然，如果工作中有需要修改 Antlr4 的 g4 文件，或者自己设计 DSL，就需要学习一些文法的知识。Antlr4 的 g4 文件格式，就是一种上下文无关的文法。</p>
<h3 id="1-2-语义"><a href="#1-2-语义" class="headerlink" title="1.2 语义"></a>1.2 语义</h3><p>语义，就是代码的含义是什么，比如上面的例子，就表示 <strong>新声明一个变量，其初值是 x 和 y 的和</strong>。</p>
<p>说的再通俗一点儿，语义，就是告诉我们这样的某一句话是什么意思，用来做什么事情的，比如日常交流的时候，问“你吃饭了没？”，就不是问题“你要去哪里？”。</p>
<p>我们大部分的分析，都需要结合程序的语义进行分析，我们需要知道代码的作用，才能知道代码可能有什么问题。我们知道某段代码执行了打印的动作，我们才能去看是否有敏感信息泄露的问题，而不会在上面查 SQL 注入的问题。</p>
<p>至于涉及到程序设计的语义分析（比如操作语义、指称语义、公理语义什么的），这些我们都不用关心。到我们程序分析这一层，就是知道这段代码执行的结果会是什么，就可以了。</p>
<h2 id="2-常用的程序分析的表示"><a href="#2-常用的程序分析的表示" class="headerlink" title="2. 常用的程序分析的表示"></a>2. 常用的程序分析的表示</h2><p>下面会将程序分析的程序表示分成几部分：</p>
<h3 id="2-1-AST、三地址码、SSA形式"><a href="#2-1-AST、三地址码、SSA形式" class="headerlink" title="2.1 AST、三地址码、SSA形式"></a>2.1 AST、三地址码、SSA形式</h3><p>这三个概念，都是程序的直接转换表示，可以认为是原代码的其它等价形式。</p>
<ul>
<li>这三个概念的含义，请参考 <a href="https://maijun-sec.github.io/2022/10/24/program-representation-ast-ssa/">静态代码分析中间表示基本概念——AST、三地址码、CFG、SSA概念</a>。</li>
<li>AST 的生成方式和获取，请参考 <a href="https://maijun-sec.github.io/2022/10/25/program-representation-ast-gen/">用于静态代码分析的程序表示——AST获取</a>。</li>
<li>三地址码 的生成方式介绍，<font color="red">待补充</font></li>
</ul>
<h3 id="2-2-CFG、BasicBlock"><a href="#2-2-CFG、BasicBlock" class="headerlink" title="2.2 CFG、BasicBlock"></a>2.2 CFG、BasicBlock</h3><p>这两个概念，是将程序中，每个过程转换成了图的形式，有了一点儿代码执行流的味道。</p>
<ul>
<li>涉及到这两个概念的含义，请参考 <a href="https://maijun-sec.github.io/2022/10/24/program-representation-ast-ssa/">静态代码分析中间表示基本概念——AST、三地址码、CFG、SSA概念</a>。</li>
<li>BasicBlock和CFG的构造的介绍，<font color="red">待补充</font></li>
</ul>
<h3 id="2-3-SSA"><a href="#2-3-SSA" class="headerlink" title="2.3 SSA"></a>2.3 SSA</h3><p>SSA 的生成方式介绍，<font color="red">待补充</font></p>
<h3 id="2-4-CG"><a href="#2-4-CG" class="headerlink" title="2.4 CG"></a>2.4 CG</h3><p><font color="red">待补充</font></p>
<h3 id="2-5-ICFG"><a href="#2-5-ICFG" class="headerlink" title="2.5 ICFG"></a>2.5 ICFG</h3><p><font color="red">待补充</font></p>
<h3 id="2-6-CDG、DDG、PDG、SDG"><a href="#2-6-CDG、DDG、PDG、SDG" class="headerlink" title="2.6 CDG、DDG、PDG、SDG"></a>2.6 CDG、DDG、PDG、SDG</h3><p><font color="red">待补充</font></p>
<h3 id="2-7-PAG、VFG"><a href="#2-7-PAG、VFG" class="headerlink" title="2.7 PAG、VFG"></a>2.7 PAG、VFG</h3><p><font color="red">待补充</font></p>
]]></content>
      <categories>
        <category>程序分析</category>
        <category>程序表示</category>
        <category>程序表示概述</category>
      </categories>
      <tags>
        <tag>AST</tag>
        <tag>SSA</tag>
        <tag>CFG</tag>
        <tag>程序表示</tag>
        <tag>PDG</tag>
        <tag>CDG</tag>
        <tag>DDG</tag>
        <tag>SDG</tag>
      </tags>
  </entry>
  <entry>
    <title>面向源码的静态代码分析简介</title>
    <url>/2022/10/23/sast-theory-intro/</url>
    <content><![CDATA[<h2 id="1-面向源码的静态分析概念"><a href="#1-面向源码的静态分析概念" class="headerlink" title="1. 面向源码的静态分析概念"></a>1. 面向源码的静态分析概念</h2><p>软件分析是一门非常大的学科，类型非常多。从不同的角度，可以分为不同的类型：</p>
<table>
<thead>
<tr>
<th>分类依据</th>
<th>分类结果</th>
</tr>
</thead>
<tbody><tr>
<td>分析的输入</td>
<td>基于源码的分析和基于二进制的分析</td>
</tr>
<tr>
<td>是否需要执行代码</td>
<td>静态分析和动态分析</td>
</tr>
<tr>
<td>分析方法</td>
<td>面向语法的分析和面向语义的分析</td>
</tr>
<tr>
<td>使用的具体算法</td>
<td>符号执行、抽象解释、定理证明、数据流分析等</td>
</tr>
</tbody></table>
<span id="more"></span>

<p>这里简单介绍面向源码的静态代码分析的相关的内容。从上面的几个名词约束，其分析的范围：</p>
<ul>
<li>面向源码的分析：或者是以源码为输入的分析</li>
<li>不需要运行代码：静态分析，因此分析过程中不需要运行代码</li>
<li>分析的方法和算法：基于业务目标，可涵盖可用的所有的分析方法</li>
</ul>
<p>我们从事软件开发的同事，对这类工具不会陌生，其广泛应用与我们的开发过程中，而且有非常多的典型工具。</p>
<h2 id="2-面向源码的静态分析工具的应用"><a href="#2-面向源码的静态分析工具的应用" class="headerlink" title="2. 面向源码的静态分析工具的应用"></a>2. 面向源码的静态分析工具的应用</h2><p>面向源码的静态代码分析的典型应用：</p>
<ul>
<li>编程规范遵从</li>
<li>软件缺陷及安全分析，例如死锁、数据竞争、缓冲区溢出、信息泄露、注入等；</li>
<li>缺陷分类分级：告警合并、告警等级判断</li>
<li>缺陷自动修复：Patch自动生成、代码推荐</li>
<li>程序理解：IDE工具、函数调用关系、软件构建依赖等</li>
<li>代码度量：圈复杂度、代码深度等</li>
<li>性能分析：可进行优化的代码分析，比如 for 循环等</li>
</ul>
<p>我们可以看到，面向源码的静态代码分析，主要应用与软件的开发过程，应用与 IDE 和 代码提交 及 构建过程，可以很好的和企业的 DevSecOps 过程（或者说 CI&#x2F;CD 过程）进行集成，因此应用非常广泛。相对于其它的分类的程序分析，这类工具也是最多的。</p>
<p><strong>说明</strong>：没有涉及到编译器本身的优化，主要的目的在于代码检查，本人一直接触的工作范围。</p>
<h2 id="3-面向源码的静态分析工具的实现"><a href="#3-面向源码的静态分析工具的实现" class="headerlink" title="3. 面向源码的静态分析工具的实现"></a>3. 面向源码的静态分析工具的实现</h2><p>面向源码的静态代码分析，是编译原理技术的延伸，或者说，静态代码分析技术，是随着编译原理技术发展起来的。</p>
<p>当然，不仅仅是面向源码的静态分析工具，应该说，整个软件分析，都是随着编译原理技术延伸出来的。因此，编译原理的相关知识，是软件分析的基础。</p>
<p>我们通常实现一款面向源码的分析工具，就是实现一款可以自动分析一个程序，可以自动分析出上面提到的可以做到的那些应用（程序的正确性、可靠性、安全性等）。</p>
<p>为了能够很好地实现这样的一款工具，从大方向上，需要下面的两点内容：</p>
<ul>
<li>精确的程序表示（例如AST，CFG，CG，IR，SSA，CDG，DDG，PDG，SDG等）</li>
<li>系统的方法（数据流分析、符号执行、抽象解释等）基于这个表示来推导是否有某种属性（某类问题或者缺陷）</li>
</ul>
<p>这一部分可以延伸出来很多的知识点，上面提到的概念也有点儿多，后面会进行一系列地介绍。这里宽泛的解释就是：我们要自动地分析源码，就首先需要把源码表示成某种等价的适合分析的形式，然后用特定的分析算法，来分析这种形式，从而得到分析结果（前面提到的可以做到的事情）。</p>
<h2 id="4-面向源码的静态分析的矛盾点"><a href="#4-面向源码的静态分析的矛盾点" class="headerlink" title="4. 面向源码的静态分析的矛盾点"></a>4. 面向源码的静态分析的矛盾点</h2><h3 id="4-1-误报和漏报情况"><a href="#4-1-误报和漏报情况" class="headerlink" title="4.1 误报和漏报情况"></a>4.1 误报和漏报情况</h3><h4 id="4-1-1-莱斯定理"><a href="#4-1-1-莱斯定理" class="headerlink" title="4.1.1 莱斯定理"></a>4.1.1 莱斯定理</h4><p>经典的<strong>莱斯定理</strong>：关于程序行为的任何非平凡属性，都不存在可以检查该属性的通用算法。</p>
<ul>
<li>平凡属性：要么对全体程序都为真，要么对全体程序都为假</li>
<li>非平凡属性：不是平凡的所有属性（比如是否存在空指针，是否存在注入等）</li>
</ul>
<p>关于程序行为：即能定义在程序上的属性。所以，从 莱斯定理来看，误报和漏报总是会存在，不可避免（当然，针对的是非平凡属性）。</p>
<h4 id="4-1-2-几个相关的概念"><a href="#4-1-2-几个相关的概念" class="headerlink" title="4.1.2 几个相关的概念"></a>4.1.2 几个相关的概念</h4><p>从分析的结果讲，对缺陷分类，有FP，FN之类的几个概念：</p>
<table>
<thead>
<tr>
<th></th>
<th>工具有扫描出来缺陷</th>
<th>工具没有扫描出来缺陷</th>
</tr>
</thead>
<tbody><tr>
<td>实际有缺陷</td>
<td>TP(True Positive)</td>
<td>FN(False Negative)</td>
</tr>
<tr>
<td>实际没有缺陷</td>
<td>FP(False Positive)</td>
<td>TN(True Negative)</td>
</tr>
</tbody></table>
<p>从分析的精度情况，有 sound 和 complete 等概念：</p>
<ul>
<li>sound：分析的结果包含了全部的正确结果，但是有可能包含部分错误的结果</li>
<li>complete：分析的结果都是对的，但是可能不全</li>
</ul>
<p>大家可以看看下面的图：<br><img src="/2022/10/23/sast-theory-intro/sound_complete.png" alt="sound and complete description"></p>
<p>从实际分析来看，我们实现的工具，经常都是既不 sound，又不 complete，因为我们要在分析的性能上做大，当然有时候也的确是咱们能力达不到，举几个实际的情况：</p>
<ul>
<li>跨过程分析时，分析1-2层，上下文还比较准确，等分析的层数越多，就越不准</li>
<li>某个函数，因为是个公共函数，被调用了几百次，我们还要不要每次都分析到呢？</li>
<li>Java 里面的泛型、反射</li>
<li>第三方库的建模</li>
<li>…</li>
</ul>
<p>现实中，有非常非常多的语法特性，使我们的分析变得不准确。</p>
<p>从实现上，sound 一般对应的是 <strong>过近似（upper&#x2F;over-approximate）</strong>，complete 一般对应的是 <strong>欠近似（lower&#x2F;under-approximate）</strong>。</p>
<p>从另外一个角度：sound 是 <strong>may analysis</strong>，就是分析结果可能是符合某个属性的分析，complete 是 <strong>must analysis</strong>，就是分析结果必须是符合某个属性。</p>
<h4 id="4-1-3-sound-和-complete-哪个更重要？"><a href="#4-1-3-sound-和-complete-哪个更重要？" class="headerlink" title="4.1.3 sound 和 complete 哪个更重要？"></a>4.1.3 sound 和 complete 哪个更重要？</h4><p>这个问题，换个问法就是 报全 和 报准 哪个更重要？</p>
<p>这个问题不好说，不同的人有不同的回答：</p>
<p>审计的同事：报全更重要，可能的问题充分暴露出来，只要有一条是正确的，就是有价值的。</p>
<p>告警清理的同事：报准更重要，误报高会带来大量的无效工作，时间都浪费掉了。</p>
<p>某些领导：就不能报全，还没有误报吗？</p>
<p>我想说的是：如果是第三方工具提供商，建议提供个参数给用户选择尽量报全还是尽量报准，如果是在企业内部，开发的工具是给内部用的，那么我的想法就是：在少点儿投诉的情况下，尽量满足领导的要求。</p>
<h3 id="4-2-分析性能"><a href="#4-2-分析性能" class="headerlink" title="4.2 分析性能"></a>4.2 分析性能</h3><p>主要的考虑点：</p>
<ul>
<li>企业构建流程集成的需要</li>
</ul>
<p>面向源码的静态代码分析工具，在企业中进行选用的时候，一般都是放在DevSecOps（或CI&#x2F;CD）流程中的，为了能够及时出来分析结果，有非常高的性能要求，因为持续构建流水线有时间窗，无法在这中间出来结果，则表示工具不可用；</p>
<ul>
<li>程序员解决问题具有时效性</li>
</ul>
<p>从经验来看，程序员开发完代码后，在功能完备的情况下，越晚报出相关缺陷，程序员修改的意愿越低。其实很合理，如果我实现了个功能，第二天早上告诉我说有点儿问题，我可能还乐意修改，但是如果隔一个月告诉我有问题，我可能就不想动了。</p>
<p>从实际情况来看，性能有时候，比准确性还重要，尤其是在企业应用的环境下。有些没有这方面概念的领导，会无限压榨工具的开发同事，要求提高分析的性能（本人曾经遇到过百万行代码要求秒级分析完成的要求）。</p>
<h2 id="5-面向源码的静态代码分析的部分新发展趋势"><a href="#5-面向源码的静态代码分析的部分新发展趋势" class="headerlink" title="5. 面向源码的静态代码分析的部分新发展趋势"></a>5. 面向源码的静态代码分析的部分新发展趋势</h2><ul>
<li>AI在静态代码分析中的应用</li>
</ul>
<p>随着积累的缺陷数据增加，基于机器学习、数据挖掘等技术，检查缺陷、识别误报、对缺陷进行分类等，是一个很重要的应用方向，相关的论文非常多；</p>
<ul>
<li>随着分布式计算发展，规模代码的快速分析成为现实</li>
</ul>
<p>对于大工程，通过拆分成不同的任务，并行分析，甚至是分发到不同的机器上执行，可以有效节省时间。参考南京大学左志强老师相关的研究。</p>
<ul>
<li>静态分析在软件工程领域的深度融合</li>
</ul>
<p>围绕静态分析的应用，在软件工程领域形成的一系列应用，参考 华为梁广泰 在 SIG-程序分析 中的分享。</p>
<ul>
<li>其它</li>
</ul>
<p>当然，程序分析相关的技术的研究，一直都还非常活跃，比如 面向特定语言的指向分析、形式化验证、特定类型缺陷的检查、缺陷自动化修复、程序合成 等。</p>
<h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h2><ul>
<li>北京大学 熊英飞 教学系列</li>
<li>南京大学 谭添、李樾 系列视频</li>
<li>左志强 系统化程序分析</li>
<li>梁广泰 基于软件分析的智能化开发新型服务与技术</li>
</ul>
]]></content>
      <categories>
        <category>程序分析</category>
        <category>程序分析简介</category>
      </categories>
      <tags>
        <tag>程序分析</tag>
      </tags>
  </entry>
</search>
