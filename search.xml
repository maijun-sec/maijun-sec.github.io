<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>用于静态代码分析的程序表示</title>
    <url>/2022/10/24/program-representation/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>程序分析</category>
        <category>程序表示</category>
      </categories>
      <tags>
        <tag>程序表示</tag>
        <tag>AST</tag>
        <tag>CFG</tag>
        <tag>PDG</tag>
        <tag>CDG</tag>
        <tag>DDG</tag>
        <tag>SDG</tag>
        <tag>SSA</tag>
      </tags>
  </entry>
  <entry>
    <title>面向源码的静态代码分析简介</title>
    <url>/2022/10/23/sast-theory-intro/</url>
    <content><![CDATA[<h2 id="1-面向源码的静态分析概念"><a href="#1-面向源码的静态分析概念" class="headerlink" title="1. 面向源码的静态分析概念"></a>1. 面向源码的静态分析概念</h2><p>软件分析是一门非常大的学科，类型非常多。从不同的角度，可以分为不同的类型：</p>
<table>
<thead>
<tr>
<th>分类依据</th>
<th>分类结果</th>
</tr>
</thead>
<tbody><tr>
<td>分析的输入</td>
<td>基于源码的分析和基于二进制的分析</td>
</tr>
<tr>
<td>是否需要执行代码</td>
<td>静态分析和动态分析</td>
</tr>
<tr>
<td>分析方法</td>
<td>面向语法的分析和面向语义的分析</td>
</tr>
<tr>
<td>使用的具体算法</td>
<td>符号执行、抽象解释、定理证明、数据流分析等</td>
</tr>
</tbody></table>
<span id="more"></span>

<p>这里简单介绍面向源码的静态代码分析的相关的内容。从上面的几个名词约束，其分析的范围：</p>
<ul>
<li>面向源码的分析：或者是以源码为输入的分析</li>
<li>不需要运行代码：静态分析，因此分析过程中不需要运行代码</li>
<li>分析的方法和算法：基于业务目标，可涵盖可用的所有的分析方法</li>
</ul>
<p>我们从事软件开发的同事，对这类工具不会陌生，其广泛应用与我们的开发过程中，而且有非常多的典型工具。</p>
<h2 id="2-面向源码的静态分析工具的应用"><a href="#2-面向源码的静态分析工具的应用" class="headerlink" title="2. 面向源码的静态分析工具的应用"></a>2. 面向源码的静态分析工具的应用</h2><p>面向源码的静态代码分析的典型应用：</p>
<ul>
<li>编程规范遵从</li>
<li>软件缺陷及安全分析，例如死锁、数据竞争、缓冲区溢出、信息泄露、注入等；</li>
<li>缺陷分类分级：告警合并、告警等级判断</li>
<li>缺陷自动修复：Patch自动生成、代码推荐</li>
<li>程序理解：IDE工具、函数调用关系、软件构建依赖等</li>
<li>代码度量：圈复杂度、代码深度等</li>
<li>性能分析：可进行优化的代码分析，比如 for 循环等</li>
</ul>
<p>我们可以看到，面向源码的静态代码分析，主要应用与软件的开发过程，应用与 IDE 和 代码提交 及 构建过程，可以很好的和企业的 DevSecOps 过程（或者说 CI&#x2F;CD 过程）进行集成，因此应用非常广泛。相对于其它的分类的程序分析，这类工具也是最多的。</p>
<p><strong>说明</strong>：没有涉及到编译器本身的优化，主要的目的在于代码检查，本人一直接触的工作范围。</p>
<h2 id="3-面向源码的静态分析工具的实现"><a href="#3-面向源码的静态分析工具的实现" class="headerlink" title="3. 面向源码的静态分析工具的实现"></a>3. 面向源码的静态分析工具的实现</h2><p>面向源码的静态代码分析，是编译原理技术的延伸，或者说，静态代码分析技术，是随着编译原理技术发展起来的。</p>
<p>当然，不仅仅是面向源码的静态分析工具，应该说，整个软件分析，都是随着编译原理技术延伸出来的。因此，编译原理的相关知识，是软件分析的基础。</p>
<p>我们通常实现一款面向源码的分析工具，就是实现一款可以自动分析一个程序，可以自动分析出上面提到的可以做到的那些应用（程序的正确性、可靠性、安全性等）。</p>
<p>为了能够很好地实现这样的一款工具，从大方向上，需要下面的两点内容：</p>
<ul>
<li>精确的程序表示（例如AST，CFG，CG，IR，SSA，CDG，DDG，PDG，SDG等）</li>
<li>系统的方法（数据流分析、符号执行、抽象解释等）基于这个表示来推导是否有某种属性（某类问题或者缺陷）</li>
</ul>
<p>这一部分可以延伸出来很多的知识点，上面提到的概念也有点儿多，后面会进行一系列地介绍。这里宽泛的解释就是：我们要自动地分析源码，就首先需要把源码表示成某种等价的适合分析的形式，然后用特定的分析算法，来分析这种形式，从而得到分析结果（前面提到的可以做到的事情）。</p>
<h2 id="4-面向源码的静态分析的矛盾点"><a href="#4-面向源码的静态分析的矛盾点" class="headerlink" title="4. 面向源码的静态分析的矛盾点"></a>4. 面向源码的静态分析的矛盾点</h2><h3 id="4-1-误报和漏报情况"><a href="#4-1-误报和漏报情况" class="headerlink" title="4.1 误报和漏报情况"></a>4.1 误报和漏报情况</h3><h4 id="4-1-1-莱斯定理"><a href="#4-1-1-莱斯定理" class="headerlink" title="4.1.1 莱斯定理"></a>4.1.1 莱斯定理</h4><p>经典的<strong>莱斯定理</strong>：关于程序行为的任何非平凡属性，都不存在可以检查该属性的通用算法。</p>
<ul>
<li>平凡属性：要么对全体程序都为真，要么对全体程序都为假</li>
<li>非平凡属性：不是平凡的所有属性（比如是否存在空指针，是否存在注入等）</li>
</ul>
<p>关于程序行为：即能定义在程序上的属性。所以，从 莱斯定理来看，误报和漏报总是会存在，不可避免（当然，针对的是非平凡属性）。</p>
<h4 id="4-1-2-几个相关的概念"><a href="#4-1-2-几个相关的概念" class="headerlink" title="4.1.2 几个相关的概念"></a>4.1.2 几个相关的概念</h4><p>从分析的结果讲，对缺陷分类，有FP，FN之类的几个概念：</p>
<table>
<thead>
<tr>
<th></th>
<th>工具有扫描出来缺陷</th>
<th>工具没有扫描出来缺陷</th>
</tr>
</thead>
<tbody><tr>
<td>实际有缺陷</td>
<td>TP(True Positive)</td>
<td>FN(False Negative)</td>
</tr>
<tr>
<td>实际没有缺陷</td>
<td>FP(False Positive)</td>
<td>TN(True Negative)</td>
</tr>
</tbody></table>
<p>从分析的精度情况，有 sound 和 complete 等概念：</p>
<ul>
<li>sound：分析的结果包含了全部的正确结果，但是有可能包含部分错误的结果</li>
<li>complete：分析的结果都是对的，但是可能不全</li>
</ul>
<p>大家可以看看下面的图：<br><img src="/2022/10/23/sast-theory-intro/sound_complete.png" alt="sound and complete description"></p>
<p>从实际分析来看，我们实现的工具，经常都是既不 sound，又不 complete，因为我们要在分析的性能上做大，当然有时候也的确是咱们能力达不到，举几个实际的情况：</p>
<ul>
<li>跨过程分析时，分析1-2层，上下文还比较准确，等分析的层数越多，就越不准</li>
<li>某个函数，因为是个公共函数，被调用了几百次，我们还要不要每次都分析到呢？</li>
<li>Java 里面的泛型、反射</li>
<li>第三方库的建模</li>
<li>…</li>
</ul>
<p>现实中，有非常非常多的语法特性，使我们的分析变得不准确。</p>
<p>从实现上，sound 一般对应的是 <strong>过近似（upper&#x2F;over-approximate）</strong>，complete 一般对应的是 <strong>欠近似（lower&#x2F;under-approximate）</strong>。</p>
<p>从另外一个角度：sound 是 <strong>may analysis</strong>，就是分析结果可能是符合某个属性的分析，complete 是 <strong>must analysis</strong>，就是分析结果必须是符合某个属性。</p>
<h4 id="4-1-3-sound-和-complete-哪个更重要？"><a href="#4-1-3-sound-和-complete-哪个更重要？" class="headerlink" title="4.1.3 sound 和 complete 哪个更重要？"></a>4.1.3 sound 和 complete 哪个更重要？</h4><p>这个问题，换个问法就是 报全 和 报准 哪个更重要？</p>
<p>这个问题不好说，不同的人有不同的回答：</p>
<p>审计的同事：报全更重要，可能的问题充分暴露出来，只要有一条是正确的，就是有价值的。</p>
<p>告警清理的同事：报准更重要，误报高会带来大量的无效工作，时间都浪费掉了。</p>
<p>某些领导：就不能报全，还没有误报吗？</p>
<p>我想说的是：如果是第三方工具提供商，建议提供个参数给用户选择尽量报全还是尽量报准，如果是在企业内部，开发的工具是给内部用的，那么我的想法就是：在少点儿投诉的情况下，尽量满足领导的要求。</p>
<h3 id="4-2-分析性能"><a href="#4-2-分析性能" class="headerlink" title="4.2 分析性能"></a>4.2 分析性能</h3><p>主要的考虑点：</p>
<ul>
<li>企业构建流程集成的需要</li>
</ul>
<p>面向源码的静态代码分析工具，在企业中进行选用的时候，一般都是放在DevSecOps（或CI&#x2F;CD）流程中的，为了能够及时出来分析结果，有非常高的性能要求，因为持续构建流水线有时间窗，无法在这中间出来结果，则表示工具不可用；</p>
<ul>
<li>程序员解决问题具有时效性</li>
</ul>
<p>从经验来看，程序员开发完代码后，在功能完备的情况下，越晚报出相关缺陷，程序员修改的意愿越低。其实很合理，如果我实现了个功能，第二天早上告诉我说有点儿问题，我可能还乐意修改，但是如果隔一个月告诉我有问题，我可能就不想动了。</p>
<p>从实际情况来看，性能有时候，比准确性还重要，尤其是在企业应用的环境下。有些没有这方面概念的领导，会无限压榨工具的开发同事，要求提高分析的性能（本人曾经遇到过百万行代码要求秒级分析完成的要求）。</p>
<h2 id="5-面向源码的静态代码分析的部分新发展趋势"><a href="#5-面向源码的静态代码分析的部分新发展趋势" class="headerlink" title="5. 面向源码的静态代码分析的部分新发展趋势"></a>5. 面向源码的静态代码分析的部分新发展趋势</h2><ul>
<li>AI在静态代码分析中的应用</li>
</ul>
<p>随着积累的缺陷数据增加，基于机器学习、数据挖掘等技术，检查缺陷、识别误报、对缺陷进行分类等，是一个很重要的应用方向，相关的论文非常多；</p>
<ul>
<li>随着分布式计算发展，规模代码的快速分析成为现实</li>
</ul>
<p>对于大工程，通过拆分成不同的任务，并行分析，甚至是分发到不同的机器上执行，可以有效节省时间。参考南京大学左志强老师相关的研究。</p>
<ul>
<li>静态分析在软件工程领域的深度融合</li>
</ul>
<p>围绕静态分析的应用，在软件工程领域形成的一系列应用，参考 华为梁广泰 在 SIG-程序分析 中的分享。</p>
<ul>
<li>其它</li>
</ul>
<p>当然，程序分析相关的技术的研究，一直都还非常活跃，比如 面向特定语言的指向分析、形式化验证、特定类型缺陷的检查、缺陷自动化修复、程序合成 等。</p>
<h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h2><ul>
<li>北京大学 熊英飞 教学系列</li>
<li>南京大学 谭添、李樾 系列视频</li>
<li>左志强 系统化程序分析</li>
<li>梁广泰 基于软件分析的智能化开发新型服务与技术</li>
</ul>
]]></content>
      <categories>
        <category>程序分析</category>
        <category>程序分析简介</category>
      </categories>
      <tags>
        <tag>程序分析</tag>
      </tags>
  </entry>
</search>
